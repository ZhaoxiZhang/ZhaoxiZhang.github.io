<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZhaoxiZhang</title>
  <subtitle>Stay Hungry, Stay Foolish.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhaoxizhang.github.io/"/>
  <updated>2018-05-31T12:55:12.872Z</updated>
  <id>https://zhaoxizhang.github.io/</id>
  
  <author>
    <name>ZhaoxiZhang</name>
    <email>ZhaoxiCheung@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java中static的用法</title>
    <link href="https://zhaoxizhang.github.io/2018/05/31/The-use-of-static-in-Java/"/>
    <id>https://zhaoxizhang.github.io/2018/05/31/The-use-of-static-in-Java/</id>
    <published>2018-05-30T16:00:00.000Z</published>
    <updated>2018-05-31T12:55:12.872Z</updated>
    
    <content type="html"><![CDATA[<h2 id="静态域"><a href="#静态域" class="headerlink" title="静态域"></a>静态域</h2><p>&nbsp;&nbsp;如果将域定义为 static，每个类中只有一个这样的域。而每一个对象对于所有的实例域却都有自己的一份拷贝。例如，假定需要给每一个雇员赋予唯一的标识码，这里给 Employee 类添加一个实例域 id 和一个静态域 nextId：<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> nextId = <span class="number">1</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;现在，每一个雇员对象都有一个自己的 id 域，但这个类的所有实例将共享一个 nextId。nextId 属于类，而不属于任何一个对象，没有对象的存在，静态域 nextId 也存在。<br>&nbsp;&nbsp;对于静态变量，静态常量在 Java 中更为常见，我们平常中比较熟悉的 Math 类中就定义有静态常量供我们直接使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span></span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> E = <span class="number">2.7182818284590452354</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.14159265358979323846</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于静态域，其使用场景一般用于：</p>
<ul>
<li>在对象之间共享数据</li>
<li>方便访问</li>
</ul>
<h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>&nbsp;&nbsp;同样，我们仍然可以在 Math 类中看到很多的静态方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">sin</span><span class="params">(<span class="keyword">double</span> a)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> StrictMath.sin(a);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">cos</span><span class="params">(<span class="keyword">double</span> a)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> StrictMath.cos(a);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;对于静态方法的调用，我们可以使用“类名.方法名”的方式，也可以使用“对象名.方法名”的方式调用，静态方法在访问本类的成员的时候，只允许访问静态成员（即静态变（常）量和静态方法），而不允许访问实例成员，因为实例成员与具体的对象关联，而静态方法属于类，不与任何对象绑定。</p>
<h2 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h2><p>&nbsp;&nbsp;可以将多个静态初始化动作组织成一个特殊的“静态子句”构成静态代码块：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">static</span>&#123;</div><div class="line">        i = <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于上述代码，实际就是一段跟在 static 关键字后面的代码，与其他静态初始化动作一样，这段代码只执行一次：当首次生成这个类的一个对象时，或者首次访问属于那个类的静态数据成员时（即便从未生成过那个类的对象）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cup</span></span>&#123;</div><div class="line">    Cup(<span class="keyword">int</span> marker)&#123;</div><div class="line">        System.out.println(<span class="string">"Cup("</span> + marker + <span class="string">")"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> marker)</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"f("</span> + marker + <span class="string">")"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cups</span></span>&#123;</div><div class="line">    <span class="keyword">static</span> Cup cup1;</div><div class="line">    <span class="keyword">static</span> Cup cup2;</div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        cup1 = <span class="keyword">new</span> Cup(<span class="number">1</span>);</div><div class="line">        cup2 = <span class="keyword">new</span> Cup(<span class="number">2</span>);</div><div class="line">    &#125;</div><div class="line">    Cups()&#123;</div><div class="line">        System.out.println(<span class="string">"Cups()"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExplicitStatic</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"Inside main()"</span>);</div><div class="line">        <span class="comment">//Cups.cup1.f(99);   //(1)</span></div><div class="line">        Cups cups = <span class="keyword">new</span> Cups();  <span class="comment">//(2)</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*执行（1）处的代码，其输出如下：</span></div><div class="line"><span class="comment">    Inside main()</span></div><div class="line"><span class="comment">    Cup(1)</span></div><div class="line"><span class="comment">    Cup(2)</span></div><div class="line"><span class="comment">    f(99)</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">执行（2）处的代码，其输出如下：</span></div><div class="line"><span class="comment">    Inside main()</span></div><div class="line"><span class="comment">    Cup(1)</span></div><div class="line"><span class="comment">    Cup(2)</span></div><div class="line"><span class="comment">    Cups()</span></div><div class="line"><span class="comment">*/</span></div></pre></td></tr></table></figure></p>
<p>值得注意的是，对于执行（2）的代码，<strong>静态代码块中的内容优于构造器先执行</strong>。另外，如果（1），（2）的代码都不执行，那么静态代码块中的代码也不会得到执行。</p>
<h2 id="static与final"><a href="#static与final" class="headerlink" title="static与final"></a>static与final</h2><p>static与final连用修饰成员，一般作为全局常量使用，其修饰的变量无法修改，修饰的方法无法被覆盖。</p>
<h2 id="static常见面试题"><a href="#static常见面试题" class="headerlink" title="static常见面试题"></a>static常见面试题</h2><ul>
<li>非静态内部类里面为什么不能有静态属性和静态方法<br>static 类型的属性和方法在类加载的时候就会存在于内存中，要使用某个类的 static 属性或者方法的前提是这个类已经加载到 JVM 中，非 static 内部类默认是持有外部类的引用且依赖外部类存在，所以如果一个非 static 的内部类一旦具有 static 的属性或者方法就会出现内部类未加载时却试图在内存中创建内部类的 static 属性和方法，这自然是错误的，类都不存在（没被加载）却希望操作它的属性和方法。从另一个角度讲非 static 的内部类在实例化的时候才会加载（不自动跟随主类加载），而 static 的语义是类能直接通过类名来访问类的 static 属性或者方法，所以如果没有实例化非 static 的内部类就等于非 static 的内部类没有被加载，所以无从谈起通过类名访问 static 属性或者方法。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;静态域&quot;&gt;&lt;a href=&quot;#静态域&quot; class=&quot;headerlink&quot; title=&quot;静态域&quot;&gt;&lt;/a&gt;静态域&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;如果将域定义为 static，每个类中只有一个这样的域。而每一个对象对于所有的实例域却都有自己的一份拷贝。例如，假定需要给每一个雇员赋予唯一的标识码，这里给 Employee 类添加一个实例域 id 和一个静态域 nextId：&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://zhaoxizhang.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>减小APK大小</title>
    <link href="https://zhaoxizhang.github.io/2018/04/21/%E5%87%8F%E5%B0%8FAPK%E5%A4%A7%E5%B0%8F/"/>
    <id>https://zhaoxizhang.github.io/2018/04/21/减小APK大小/</id>
    <published>2018-04-20T16:00:00.000Z</published>
    <updated>2018-04-21T06:45:11.532Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章翻译自<a href="https://developer.android.com/topic/performance/reduce-apk-size.html#apk-structure" target="_blank" rel="external">Reduce APK Size</a></p>
<p>  用户通常不会去下载体积过大的应用程序，特别是当自己的设备连接的是 2G/3G 或者按字节付费的网络。这篇文章描述了如何缩减 APK 的体积大小，以使得更多用户愿意下载你开发的应用。<br><a id="more"></a></p>
<h2 id="了解APK结构"><a href="#了解APK结构" class="headerlink" title="了解APK结构"></a>了解APK结构</h2><p>  在讨论如何缩减你应用的体积之前，了解 APK 结构是非常有益处的。一个 APK 文件包含了一个 ZIP 文件，该 ZIP 文件包含了组成你应用的所有文件，这些文件包括 Java 字节码文件、资源文件和已编译资源的文件。<br>APK 包含下列目录：</p>
<ul>
<li><code>META-INF/</code>：包含了<code>CERT.SF</code>、<code>CERT.RSA</code>签名文件以及<code>MAINFEST.MF</code>mainfest文件</li>
<li><code>assets/</code>：包含了应用程序的资源，应用程序可以通过 <a href="https://developer.android.com/reference/android/content/res/AssetManager.html" target="_blank" rel="external">AssetManager</a> 检索资源</li>
<li><code>res/</code>：包含了没有编译到<code>resources.arsc</code>的资源</li>
<li><code>lib/</code>：包含了特定处理器的软件层的编译代码，该目录包含了每个平台类型的子目录，例如<code>armeabi</code>、<code>armeabi-v7a</code>、<code>arm64-v8a</code>、<code>x86</code>、<code>x86_64</code>和<code>mips</code></li>
</ul>
<p>APK 也包含了下列文件，在这些文件之中，只有<code>Mainfest.xml</code>是强制的</p>
<ul>
<li><code>resources.arsc</code>：包含了编译的资源，该文件包含了来自<code>res/values/</code>目录下所有配置的XML内容。打包工具提取此XML内容，将其编译为二进制格式，并归档内容。此内容包含了语言字符串和样式，以及未直接包含在<code>resources.arsc</code>文件中的内容路径，比如布局文件和图像。<br><code>classes.dex</code>：包含了能被<code>Dalvik/ART</code>虚拟机识别的 DEX 文件格式编译的类<br><code>AndroidManifest.xml</code>：包含了 Android 核心的 mainfest 文件。该文件罗列了应用程序的名字、版本、权限和引用的第三方库。该文件使用 Android 的二进制 XML 格式</li>
</ul>
<h2 id="减少资源数量和大小"><a href="#减少资源数量和大小" class="headerlink" title="减少资源数量和大小"></a>减少资源数量和大小</h2><p>  APK 的大小会影响到应用程序启动的速度、使用的内存和消耗的电量。缩减应用程序大小最简单的方式之一就是减少它所包含的资源数量和大小。特别是你可以移除你的应用中不再使用的资源，或者使用可拓展的 <a href="https://developer.android.com/reference/android/graphics/drawable/Drawable.html" target="_blank" rel="external">Drawable</a>  对象来替代图像文件。这部分讨论的这些方法以及一些其他的方式可以减少你应用程序中的资源从而在整体上减少 APK 体积的大小。</p>
<h3 id="移除无用的资源"><a href="#移除无用的资源" class="headerlink" title="移除无用的资源"></a>移除无用的资源</h3><p>Android Studio中的静态代码检查工具——<a href="https://developer.android.com/studio/write/lint.html" target="_blank" rel="external">lint</a>可以检测<code>res/</code>目录下没有引用的资源。当 lint 检查工具发现在你项目中可能存在一个没有使用的资源，它将会打印出类似如下的信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">res/layout/preferences.xml: Warning: The resource R.layout.preferences appears</div><div class="line">    to be unused [UnusedResources]</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：lint 检查工具没有扫描<code>assets/</code>目录，assets 资源是通过反射的方式，或者链接到应用程序的库文件来发现引用的。此外，lint 检查工具并不删除这些资源，它只是提醒你它们的存在。</p>
</blockquote>
<p>你使用的一些库可能包含了一些无用的资源，如果你在 <code>build.gradle</code>文件中开启了 <a href="https://developer.android.com/studio/build/shrink-code.html" target="_blank" rel="external">shrinkResources</a>，那么 Gradle 可以帮你自动移除这些资源。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line">    <span class="comment">// Other settings</span></div><div class="line"></div><div class="line">    buildTypes &#123;</div><div class="line">        release &#123;</div><div class="line">            minifyEnabled <span class="literal">true</span></div><div class="line">            shrinkResources <span class="literal">true</span></div><div class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>要使用 shrinkResources，你必须启用代码缩减。在编译的过程，首先 <a href="https://developer.android.com/studio/build/shrink-code.html" target="_blank" rel="external">ProGuard</a> 移除无用的代码但是并不移除无用的资源，之后由 Gradle 移除无用的资源。<br>更多有关 ProGuard 和其他一些通过 Android Studio帮助你缩减 APK 体积大小的方法，可以查看<a href="https://developer.android.com/studio/build/shrink-code.html" target="_blank" rel="external">压缩代码和资源</a></p>
<h3 id="最小化库中资源的使用"><a href="#最小化库中资源的使用" class="headerlink" title="最小化库中资源的使用"></a>最小化库中资源的使用</h3><p>当开发一个 Android 应用的时候，通常会使用一些第三方库来提高应用程序的可用性和多功能性。比如，可能使用了 <a href="https://developer.android.com/topic/libraries/support-library/index.html" target="_blank" rel="external">Android Support Library</a> 来改善在旧机型上的用户体验，或者使用 <a href="https://developers.google.com/android/guides/overview" target="_blank" rel="external">Google Play Services</a> 为应用程序提供自动翻译。<br>如果一个库是为服务器或者桌面设计的，那么它通常包含了许多你的应用程序用不到的对象和方法，如果这个库所使用的协议允许，那么你可以修改这个库文件。当然，你也可以使用其他一些对于移动端友好的库来为你的应用程序添加特定功能。</p>
<blockquote>
<p>注意：ProGuard 可以清理第三方库中对你应用非必须的代码，但是它不能移除第三方库的大型内部依赖项。</p>
</blockquote>
<h3 id="只支持特定的分辨率"><a href="#只支持特定的分辨率" class="headerlink" title="只支持特定的分辨率"></a>只支持特定的分辨率</h3><p>Android 支持非常大的设备集，拥有着各式各样的分辨率。在 Android4.4（API level 19）或者更高的系统版本，其框架支持许多分辨率：<code>ldpi</code>、<code>mdpi</code>、<code>tvdpi</code>、<code>hdpi</code>、<code>xhdpi</code>、<code>xxhdpi</code>。尽管 Android 支持所有这些分辨率，但是你并不需要适配每一种分辨率。<br>如果你知道你的用户群中只有一小部分使用具有特定分辨率的设备，考虑你是否需要适配这些分辨率。如果你没有为特定分辨率准备资源文件，那么 Android 将自动缩放最初为其他屏幕分辨率设计的现有资源。<br>如果你的应用程序只需要缩放的图片，你可以通过在 <code>drawable-nodpi</code>目录中使用图片的单个版本来节省更多的空间。我们建议每个应用程序至少包含一个<code>xxhdpi</code>图片版本。<br>更多有关屏幕分辨率的信息，可以查看<a href="https://developer.android.com/about/dashboards/index.html#Screens" target="_blank" rel="external">屏幕尺寸和密度</a></p>
<h3 id="使用drawable对象"><a href="#使用drawable对象" class="headerlink" title="使用drawable对象"></a>使用drawable对象</h3><p>一些图像并不需要一个静态的图像资源，frameworker 可以在运行时动态的绘制出图像。<a href="https://developer.android.com/reference/android/graphics/drawable/Drawable.html" target="_blank" rel="external">Drawable</a> 对象占用APK中少量空间。此外，XML形式的 <a href="https://developer.android.com/reference/android/graphics/drawable/Drawable.html" target="_blank" rel="external">Drawable</a> 对象可以产生符合<code>Material Design</code>准则的单色图像。</p>
<h3 id="重用资源"><a href="#重用资源" class="headerlink" title="重用资源"></a>重用资源</h3><p>你可以为图像的不同分辨率添加一个单独的资源，比如同一图像的着色、阴影或者旋转版本。但是我们强烈建议你重用相同的资源集，在运行时根据需要定制它们。<br>Android 提供了几个实用程序来更改 asset 的颜色，在 Android5.0（API level 21）或以上版本，可以使用<code>android:tint</code>和<code>tintMode</code>属性。对于较低的系统版本，使用 <a href="https://developer.android.com/reference/android/graphics/ColorFilter.html" target="_blank" rel="external">ColorFilter</a> 类<br>你可以忽略等价于其他资源的资源。下列的代码片段提供了一个例子，通过在图像中间旋转180°将向上的标志转换成向下的标志。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">rotate</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line"><span class="tag">    <span class="attr">android:drawable</span>=<span class="string">"@drawable/ic_thumb_up"</span></span></div><div class="line"><span class="tag">    <span class="attr">android:pivotX</span>=<span class="string">"50%"</span></span></div><div class="line"><span class="tag">    <span class="attr">android:pivotY</span>=<span class="string">"50%"</span></span></div><div class="line"><span class="tag">    <span class="attr">android:fromDegrees</span>=<span class="string">"180"</span> /&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="从代码中呈现"><a href="#从代码中呈现" class="headerlink" title="从代码中呈现"></a>从代码中呈现</h3><p>我们还可以通过程序化渲染图像来缩减 APK 的体积大小。程序化渲染可以释放空间，因为你不再在APK中保存图像文件。</p>
<h3 id="压缩PNG文件"><a href="#压缩PNG文件" class="headerlink" title="压缩PNG文件"></a>压缩PNG文件</h3><p><code>aapt</code>工具在编译的过程可以无损压缩存放在<code>res/drawable/</code>目录下的资源。例如，<code>aapt</code>工具可以将不需要超过256种颜色的真彩色PNG转换为具有调色板的8位PNG。 这样会产生质量相同的图像，但内存占用空间更小。<br>记住aapt有以下限制：</p>
<ul>
<li>aapt工具不能压缩<code>asset</code>目录下的PNG文件</li>
<li>aapt工具只能优化使用不多于256位颜色的图像文件</li>
<li>aapt工具可能会填充已经压缩过的PNG图像，为了防止这种情况，你可以使用 Gradle 中的<code>cruncherEnabled</code>标志来禁用 PNG 文件的这个过程。<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">aaptOptions &#123;</div><div class="line">    cruncherEnabled = false</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="压缩PNG和JPEG文件"><a href="#压缩PNG和JPEG文件" class="headerlink" title="压缩PNG和JPEG文件"></a>压缩PNG和JPEG文件</h3><p>你可以使用类似 <a href="https://pmt.sourceforge.io/pngcrush/" target="_blank" rel="external">pngcrush</a>、<a href="https://pngquant.org/" target="_blank" rel="external">pngquant</a> 或者 <a href="https://github.com/google/zopfli" target="_blank" rel="external">zopflipng</a> 等工具来无损压缩 PNG 文件。所有这些工具都可以压缩 PNG 同时保持图像质量。<br>pngcrush 工具特别有效：这个工具通过使用过滤器和参数的各种组合来压缩图像，在 PNG 过滤器和 zlib(Deflate) 参数上迭代。它选择最小压缩输出的配置。<br>对于 JPEG 图像，你可以使用类似 <a href="http://www.elektronik.htw-aalen.de/packjpg/" target="_blank" rel="external">packJPG</a> 和 <a href="https://github.com/google/guetzli" target="_blank" rel="external">guetzli</a> 的工具来压缩。</p>
<h3 id="使用WebP文件格式"><a href="#使用WebP文件格式" class="headerlink" title="使用WebP文件格式"></a>使用WebP文件格式</h3><p>在Android 3.2（API level 13）或更高版本，除了使用 PNG 或 JPEG 格式的图像文件，你还可以使用 <a href="https://developers.google.com/speed/webp/" target="_blank" rel="external">WebP</a> 文件格式的图像。WebP 格式提供有损压缩（类似于JPEG）以及透明度（类似于PNG），但是能更好的提供比 JPEG 或 PNG 更好的压缩效果。<br>你可以使用 Android Studio 转换 BMP、JPG、PNG或者静态GIF的图像为 WebP 格式。获取更多信息，查看<a href="https://developer.android.com/studio/write/convert-webp.html" target="_blank" rel="external">创建WebP图像</a></p>
<blockquote>
<p>注意：Google Play 只接受<a href="https://material.io/guidelines/style/icons.html#" target="_blank" rel="external">启动图标</a>为 PNG 格式的 APKs</p>
</blockquote>
<h3 id="使用矢量图形"><a href="#使用矢量图形" class="headerlink" title="使用矢量图形"></a>使用矢量图形</h3><p>你可以使用矢量图形创建独立于分辨率的图标和其他可伸缩图片。 使用这些图形可以大大减少APK的大小。矢量图形在 Android 中表示为 <a href="https://developer.android.com/reference/android/graphics/drawable/VectorDrawable.html" target="_blank" rel="external">VectorDrawable</a> 对象。使用 <a href="https://developer.android.com/reference/android/graphics/drawable/VectorDrawable.html" target="_blank" rel="external">VectorDrawable</a> 对象，100字节的文件可以生成屏幕大小的清晰图像。<br>但是系统将会花费大量时间去渲染 <a href="https://developer.android.com/reference/android/graphics/drawable/VectorDrawable.html" target="_blank" rel="external">VectorDrawable</a> 对象，对于大的图像需要更长的时间才能出现在屏幕上。因此，在展示小图像的时候再考虑矢量图。<br>获取更多有关 <a href="https://developer.android.com/reference/android/graphics/drawable/VectorDrawable.html" target="_blank" rel="external">VectorDrawable</a> 对象的信息，查看<a href="https://developer.android.com/training/material/drawables.html" target="_blank" rel="external">使用图片</a></p>
<h3 id="使用矢量图形制作动画图像"><a href="#使用矢量图形制作动画图像" class="headerlink" title="使用矢量图形制作动画图像"></a>使用矢量图形制作动画图像</h3><p>不要使用 <a href="https://developer.android.com/reference/android/graphics/drawable/AnimationDrawable.html" target="_blank" rel="external">AnimationDrawable</a> 去创建逐帧动画，因为这样做需要为动画的每个帧添加单独的位图文件，这会增加 APK 的体积大小。<br>你可以使用 <a href="https://developer.android.com/reference/android/support/graphics/drawable/AnimatedVectorDrawableCompat.html" target="_blank" rel="external">AnimatedVectorDrawable</a> 为<a href="https://developer.android.com/training/material/animations.html#AnimVector" target="_blank" rel="external">矢量图片添加动画</a></p>
<h2 id="减少Native和Java代码"><a href="#减少Native和Java代码" class="headerlink" title="减少Native和Java代码"></a>减少Native和Java代码</h2><p>你可以使用下列几种方式去减少应用程序中的 Java 和 native 代码库。</p>
<h3 id="移除不必要的生成代码"><a href="#移除不必要的生成代码" class="headerlink" title="移除不必要的生成代码"></a>移除不必要的生成代码</h3><p>确保了解自动生成的代码的足迹。例如，许多协议缓冲工具生成过多的方法和类，这可能使应用程序的大小增加一倍或者两倍。</p>
<h3 id="避免枚举"><a href="#避免枚举" class="headerlink" title="避免枚举"></a>避免枚举</h3><p>一个枚举可以为你的应用程序的<code>classes.dex</code>文件增加1.0至1.4KB的大小，对于复杂系统或者共享库，这些将快速累积。如果可能的话，考虑使用<code>@IntDef</code>注解和 <a href="https://developer.android.com/studio/build/shrink-code.html" target="_blank" rel="external">ProGuard</a> 来除去枚举并将它们转换为整数。这种类型转换保留了枚举的所有类型安全的好处。</p>
<h3 id="减小本地二进制文件的大小"><a href="#减小本地二进制文件的大小" class="headerlink" title="减小本地二进制文件的大小"></a>减小本地二进制文件的大小</h3><p>如果你的应用程序使用 native code 和 Android NDK，你可以通过优化代码来减少应用程序的体积大小。两种有用的技术是删除调试符号和避免提取本地库。</p>
<ul>
<li>删除调试符号<br>如果你的应用程序正在开发并且需要调试，那么使用调试符号是很有意义的。使用 Android NDK 提供的<code>arm-eabi-strip</code>工具去移除本地库中不必要的调试符号，之后再进行 release版本的编译。</li>
<li>避免提取本地库<br>将<code>.so</code>文件保存在 APK 中未压缩的文件，设置<code> application </code>中的元素<code>android:extracNativeLibs</code>为false，这将防止 <a href="https://developer.android.com/reference/android/content/pm/PackageManager.html" target="_blank" rel="external">PackageManager</a> 在安装过程中将<code>.so</code>文件从APK复制到文件系统，并且有一个额外的好处，使得应用程序的增量更新更小。</li>
</ul>
<h2 id="维护多个精简版APK"><a href="#维护多个精简版APK" class="headerlink" title="维护多个精简版APK"></a>维护多个精简版APK</h2><p>你的 APK 可以包含用户下载但从未使用的内容，例如区域或语言信息。为了让用户下载尽量小的应用程序，你可以将你的应用程序根据屏幕尺寸或GPU纹理支持等因素细分为多个 APKs。<br>当用户下载你的应用程序的时候，根据他们的设备特点以及设置详情，他们会接收到正确的 APK，这样，设备不会接收设备没有的功能的资源。例如，一个用户有<code>hdpi</code>的设备，他们不需要为更高分辨率的设备提供的<code>xxxhdpi</code>的资源。<br>获取更多相关信息，可以查看 <a href="https://developer.android.com/studio/build/configure-apk-splits.html" target="_blank" rel="external">Configure APK Splits</a> 和 <a href="https://developer.android.com/google/play/publishing/multiple-apks.html" target="_blank" rel="external"> Maintaining Multiple APKs</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章翻译自&lt;a href=&quot;https://developer.android.com/topic/performance/reduce-apk-size.html#apk-structure&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Reduce APK Size&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;  用户通常不会去下载体积过大的应用程序，特别是当自己的设备连接的是 2G/3G 或者按字节付费的网络。这篇文章描述了如何缩减 APK 的体积大小，以使得更多用户愿意下载你开发的应用。&lt;br&gt;
    
    </summary>
    
    
      <category term="Android——性能优化" scheme="https://zhaoxizhang.github.io/tags/Android%E2%80%94%E2%80%94%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Java 8新特性</title>
    <link href="https://zhaoxizhang.github.io/2018/04/20/Java%208%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>https://zhaoxizhang.github.io/2018/04/20/Java 8新特性/</id>
    <published>2018-04-19T16:00:00.000Z</published>
    <updated>2018-04-19T16:50:20.826Z</updated>
    
    <content type="html"><![CDATA[<p>本文译自<a href="https://github.com/winterbe/java8-tutorial" target="_blank" rel="external">Java8-tutorial</a>，并对其中内容进行了一些修改和补充。<br><a id="more"></a></p>
<h2 id="接口的默认方法"><a href="#接口的默认方法" class="headerlink" title="接口的默认方法"></a>接口的默认方法</h2><p>在 Java 8 中，我们可以通过<code>default</code>关键字来为接口添加非抽象方法。<code>default</code>关键字修饰的方法称为默认方法，它允许我们添加新的功能到现有库的接口中，并能确保与采用旧版本接口编写的代码之间相互兼容。<br>对于以下例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Formula</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> Math.sqrt(a);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在<code>Formula</code>接口中，除了有抽象方法<code>calculate</code>，还定义了默认方法<code>sqrt</code>，<code>Formula</code>的实现类只需实现抽象方法<code>calculate</code>，默认方法<code>sqrt</code>可直接使用接口中的定义，也可以在具体类中重写。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Formula formula = <span class="keyword">new</span> Formula() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> sqrt(a * <span class="number">100</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">formula.calculate(<span class="number">100</span>);     <span class="comment">// 100.0</span></div><div class="line">formula.sqrt(<span class="number">16</span>);           <span class="comment">// 4.0</span></div></pre></td></tr></table></figure></p>
<p>上面的代码中，formula 以匿名对象的方式实现了<code>Formula</code>接口，而这只是为了实现<code>sqrt(a * 100)</code>，略显繁琐的，在下一部分，将讨论一种在 Java 8 中更为优雅的实现方式。</p>
<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>首先让我们用 1.8 之前的 Java 版本来对一串字符串进行排序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">"peter"</span>, <span class="string">"anna"</span>, <span class="string">"mike"</span>, <span class="string">"xenia"</span>);</div><div class="line"></div><div class="line">Collections.sort(names, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String a, String b)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> b.compareTo(a);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>静态工具方法<code>Collections.sort</code>接受一个列表和一个比较器来对给定的列表中的元素进行排序，你会发现你经常需要创建匿名比较器传给排序函数。<br>为了避免一直创建匿名对象，Java 8 通过<strong>lambad 表达式</strong>来简化语法规则：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Collections.sort(names, (String a, String b) -&gt; &#123;</div><div class="line">    <span class="keyword">return</span> b.compareTo(a);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>上面的代码更加精简，可读性也更强，当然，还可以继续精简：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));</div></pre></td></tr></table></figure></p>
<p>Lambda 表达式的主体只有一条语句时，花括号{}和<code>return</code>关键字可省略。<br>现在，列表有了一个<code>sort</code>方法，另外，当可以从上下文推断出参数的类型，同样可以省略掉参数类型。</p>
<h3 id="Lambad表达式的结构"><a href="#Lambad表达式的结构" class="headerlink" title="Lambad表达式的结构"></a>Lambad表达式的结构</h3><ul>
<li>一个 Lambda 表达式可以有零个或多个参数</li>
<li>参数的类型既可以明确声明，也可以根据上下文来推断。例如：(int a)与(a)效果相同</li>
<li>所有参数需包含在圆括号内，参数之间用逗号相隔。例如：(a, b) 或 (int a, int b) 或 (String a, int b, float c)</li>
<li>空圆括号代表参数集为空。例如：() -&gt; 42</li>
<li>当只有一个参数，且其类型可推导时，圆括号（）可省略。例如：a -&gt; return a*a</li>
<li>Lambda 表达式的主体可包含零条或多条语句</li>
<li>如果 Lambda 表达式的主体只有一条语句，花括号{}可省略。匿名函数的返回类型与该主体表达式一致</li>
<li>如果 Lambda 表达式的主体包含一条以上语句，则表达式必须包含在花括号{}中（形成代码块）。匿名函数的返回类型与代码块的返回类型一致，若没有返回则为空</li>
</ul>
<h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>Lambda 表达式如何匹配 Java 的类型系统的呢？每个 Lambda 对应一个特定的接口，与一个给定的类型相匹配，一个所谓的函数式接口只包含一个抽象方法声明，每个 Lambda 表达式都与那个类型的抽象方法匹配。因为默认方法并非抽象的，因此我们可以向函数式接口任意添加默认方法。<br>我们可以使用任意只包含一个抽象方法声明的接口来作为 Lambda 表达式，为了确保使用的是函数式接口，我们可以添加<code>@FunctionalInterface</code>注解，编译器就会察觉到这个注解，并且当我们尝试往函数式接口添加第二个抽象方法声明时抛出异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">F</span>, <span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="function">T <span class="title">convert</span><span class="params">(F from)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);</div><div class="line">Integer converted = converter.convert(<span class="string">"123"</span>);</div><div class="line">System.out.println(converted);    <span class="comment">// 123</span></div></pre></td></tr></table></figure></p>
<p>假使没有<code>@FunctionalInterface</code>注解，上述代码仍然是正确的。</p>
<h2 id="方法和构造器引用"><a href="#方法和构造器引用" class="headerlink" title="方法和构造器引用"></a>方法和构造器引用</h2><p>方法引用的分类：</p>
<ul>
<li>类名::静态方法名</li>
<li>对象::实例方法名</li>
<li>类名::实例方法名</li>
<li>类名::new</li>
</ul>
<h3 id="类名-静态方法名"><a href="#类名-静态方法名" class="headerlink" title="类名::静态方法名"></a>类名::静态方法名</h3><p>上述例子中的代码可以进一步通过静态方法引用来精简：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Converter&lt;String, Integer&gt; converter = Integer::valueOf;</div><div class="line">Integer converted = converter.convert(<span class="string">"123"</span>);</div><div class="line">System.out.println(converted);   <span class="comment">// 123</span></div></pre></td></tr></table></figure></p>
<p>Java 8 中你可以通过<code>::</code>关键字来传递方法或者构造器引用，上述的例子说明了如何引用一个静态方法。</p>
<h3 id="对象-实例方法名"><a href="#对象-实例方法名" class="headerlink" title="对象::实例方法名"></a>对象::实例方法名</h3><p>我们也可以引用一个对象方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span> </span>&#123;</div><div class="line">    <span class="function">String <span class="title">startsWith</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> String.valueOf(s.charAt(<span class="number">0</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Something something = <span class="keyword">new</span> Something();</div><div class="line">Converter&lt;String, String&gt; converter = something::startsWith;</div><div class="line">String converted = converter.convert(<span class="string">"Java"</span>);</div><div class="line">System.out.println(converted);    <span class="comment">// "J"</span></div></pre></td></tr></table></figure>
<h3 id="类名-实例方法名"><a href="#类名-实例方法名" class="headerlink" title="类名::实例方法名"></a>类名::实例方法名</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareByScore</span><span class="params">(Student student)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getScore() - student.getScore();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">students.sort(Student::compareByScore);</div><div class="line">students.forEach(student -&gt; System.out.println(student.getScore()));</div></pre></td></tr></table></figure>
<p>sort 方法接收的 Lambda 表达式本该有两个参数，而这个实例方法只有一个参数也满足 Lambda 表达式的定义。这就是 类名::实例方法名 这种方法引用的特殊之处，当使用 类名::实例方法名 方法引用时，一定是 Lambda 表达式所接收的第一个参数来调用实例方法，如果 Lambda 表达式接收多个参数，其余的参数作为方法的参数传递进去。</p>
<h3 id="类名-new"><a href="#类名-new" class="headerlink" title="类名::new"></a>类名::new</h3><p>让我们来看看<code>::</code>关键字在构造器引用中是如何使用的。首先，我们定义一个有多个构造函数的类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    String firstName;</div><div class="line">    String lastName;</div><div class="line"></div><div class="line">    Person() &#123;&#125;</div><div class="line"></div><div class="line">    Person(String firstName, String lastName) &#123;</div><div class="line">        <span class="keyword">this</span>.firstName = firstName;</div><div class="line">        <span class="keyword">this</span>.lastName = lastName;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来，我们创建一个用于创建新人员的工厂接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonFactory</span>&lt;<span class="title">P</span> <span class="keyword">extends</span> <span class="title">Person</span>&gt; </span>&#123;</div><div class="line">    <span class="function">P <span class="title">create</span><span class="params">(String firstName, String lastName)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>除了传统方式实现工厂接口外，通过构造器引用的方式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PersonFactory&lt;Person&gt; personFactory = Person::<span class="keyword">new</span>;</div><div class="line">Person person = personFactory.create(<span class="string">"Peter"</span>, <span class="string">"Parker"</span>);</div></pre></td></tr></table></figure></p>
<p>我们通过<code>Person::new</code>向 Person 构造器传了一个引用（注：Person类中需要有无参构造器），Java编译器会自动选择正确的构造器。</p>
<h2 id="Lambda作用域"><a href="#Lambda作用域" class="headerlink" title="Lambda作用域"></a>Lambda作用域</h2><p>Lambda 表达式访问外部变量的方式与匿名对象非常相似，它可以访问局部外围的 final 变量、成员变量和静态变量。</p>
<h3 id="访问局部变量"><a href="#访问局部变量" class="headerlink" title="访问局部变量"></a>访问局部变量</h3><p>我们可以在 Lambda 表达式所在的外部范围访问<code>final</code>修饰的局部变量<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">1</span>;</div><div class="line">Converter&lt;Integer, String&gt; stringConverter =</div><div class="line">        (from) -&gt; String.valueOf(from + num);</div><div class="line"></div><div class="line">stringConverter.convert(<span class="number">2</span>);     <span class="comment">// 3</span></div></pre></td></tr></table></figure></p>
<p>不同于匿名对象的是，上述变量 num 不一定要被声明为 final（匿名内部类中的参数必须声明为 final，其值是 capture by value的），下述代码也是正确的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</div><div class="line">Converter&lt;Integer, String&gt; stringConverter =</div><div class="line">        (from) -&gt; String.valueOf(from + num);</div><div class="line"></div><div class="line">stringConverter.convert(<span class="number">2</span>);     <span class="comment">// 3</span></div></pre></td></tr></table></figure></p>
<p>值得注意的是，虽然 num 变量不需要显式声明为 final，但实际上，编译器要求 Lambda 表达式中捕获的变量必须实际上是最终变量（也就是初始化后不可再赋新值）所以 num 不可更改，下述代码无法通过编译，原因就是 num 的值被更改了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</div><div class="line">Converter&lt;Integer, String&gt; stringConverter =</div><div class="line">        (from) -&gt; String.valueOf(from + num);</div><div class="line">num = <span class="number">3</span>;</div></pre></td></tr></table></figure></p>
<h3 id="访问成员变量和静态变量"><a href="#访问成员变量和静态变量" class="headerlink" title="访问成员变量和静态变量"></a>访问成员变量和静态变量</h3><p>与局部变量不同的是，Lambda 表达式中，可以对成员变量和静态变量进行读和写操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lambda4</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> outerStaticNum;</div><div class="line">    <span class="keyword">int</span> outerNum;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testScopes</span><span class="params">()</span> </span>&#123;</div><div class="line">        Converter&lt;Integer, String&gt; stringConverter1 = (from) -&gt; &#123;</div><div class="line">            outerNum = <span class="number">23</span>;</div><div class="line">            <span class="keyword">return</span> String.valueOf(from);</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        Converter&lt;Integer, String&gt; stringConverter2 = (from) -&gt; &#123;</div><div class="line">            outerStaticNum = <span class="number">72</span>;</div><div class="line">            <span class="keyword">return</span> String.valueOf(from);</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="访问接口的默认方法"><a href="#访问接口的默认方法" class="headerlink" title="访问接口的默认方法"></a>访问接口的默认方法</h3><p>在第一部分中关于 formula 的例子，<code>Formula</code>接口定义了一个<code>sqrt</code>的默认方法，其可以被任意一个 formula 实例包括匿名对象访问，但是在 Lambda 表达式中却不行，Lambda 表达式无法访问接口的默认方法，下述代码是错误的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Formula formula = (a) -&gt; sqrt(a * <span class="number">100</span>);</div></pre></td></tr></table></figure></p>
<h2 id="内置函数式接口"><a href="#内置函数式接口" class="headerlink" title="内置函数式接口"></a>内置函数式接口</h2><p>JDK 1.8 API 中包含了很多内置的函数式接口，其中一部分例如<code>Comparator</code>、<code>Runnable</code>在之前的 JDK 版本中就被人熟知。这些现有的接口通过<code>@FunctionalInterface</code>注解被拓展来支持 Lambda。<br>Java 8中的 API 也提供了一些新的函数式接口来使得编程更加简单。<br>以下是常用的函数式接口</p>
<table>
<thead>
<tr>
<th>函数式接口</th>
<th>参数类型</th>
<th>返回类型</th>
<th>抽象方法名</th>
<th>描述</th>
<th>其他方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>Runnable</td>
<td>无</td>
<td>void</td>
<td>run</td>
<td>作为无参数或返回值的动作运行</td>
<td></td>
</tr>
<tr>
<td>Supplier<t></t></td>
<td>无</td>
<td>T</td>
<td>get</td>
<td>提供一个T类型的值</td>
<td></td>
</tr>
<tr>
<td>Consumer<t></t></td>
<td>T</td>
<td>void</td>
<td>accept</td>
<td>处理一个T类型的值</td>
<td>andThen</td>
</tr>
<tr>
<td>BiConsumer<t,u></t,u></td>
<td>T,U</td>
<td>void</td>
<td>accept</td>
<td>处理T和U类型的值</td>
<td>andThen</td>
</tr>
<tr>
<td>Function<t,r></t,r></td>
<td>T</td>
<td>R</td>
<td>apply</td>
<td>有一个T类型参数的函数</td>
<td>compose,andThen,identity</td>
</tr>
<tr>
<td>BiFunction<t,u,r></t,u,r></td>
<td>T,U</td>
<td>R</td>
<td>apply</td>
<td>有T和U类型参数的函数</td>
<td>andThen</td>
</tr>
<tr>
<td>UnaryOperator<t></t></td>
<td>T</td>
<td>T</td>
<td>apply</td>
<td>类型T上的一元操作符</td>
<td>compose,andThen,identity</td>
</tr>
<tr>
<td>BinaryOperator<t></t></td>
<td>T,T</td>
<td>T</td>
<td>apply</td>
<td>类型T上的二元操作符</td>
<td>andThen,maxBy,minBy</td>
</tr>
<tr>
<td>Predicate<t></t></td>
<td>T</td>
<td>boolean</td>
<td>test</td>
<td>布尔值函数</td>
<td>and,or,negate,isEqual</td>
</tr>
<tr>
<td>BiPredicate<t,u></t,u></td>
<td>T,U</td>
<td>boolean</td>
<td>test</td>
<td>有两个参数的布尔值函数</td>
<td>and,or,negate</td>
</tr>
</tbody>
</table>
<h3 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h3><p><code>Predicate</code> 是一个布尔类型的函数，该函数只有一个参数，该接口包含了多种默认方法，用于处理复杂的逻辑动词。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; <span class="number">0</span>;</div><div class="line"></div><div class="line">predicate.test(<span class="string">"foo"</span>);              <span class="comment">// true</span></div><div class="line">predicate.negate().test(<span class="string">"foo"</span>);     <span class="comment">// false</span></div><div class="line"></div><div class="line">Predicate&lt;Boolean&gt; nonNull = Objects::nonNull;</div><div class="line">Predicate&lt;Boolean&gt; isNull = Objects::isNull;</div><div class="line"></div><div class="line">Predicate&lt;String&gt; isEmpty = String::isEmpty;</div><div class="line">Predicate&lt;String&gt; isNotEmpty = isEmpty.negate();</div></pre></td></tr></table></figure></p>
<h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><p><code>Function</code>接受一个参数并且返回一个结果，可以使用默认方法（compose，andThen）将多个函数链接起来。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Function&lt;String, Integer&gt; toInteger = Integer::valueOf;</div><div class="line">Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);</div><div class="line"></div><div class="line">backToString.apply(<span class="string">"123"</span>);     <span class="comment">// "123"</span></div></pre></td></tr></table></figure></p>
<h3 id="Supplier"><a href="#Supplier" class="headerlink" title="Supplier"></a>Supplier</h3><p><code>Supplier</code>返回一个给定类型的结果，与<code>Function</code>不同的是，<code>Supplier</code>不接受任何参数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Supplier&lt;Person&gt; personSupplier = Person::<span class="keyword">new</span>;</div><div class="line">personSupplier.get();   <span class="comment">// new Person</span></div></pre></td></tr></table></figure></p>
<h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p><code>Comsumer</code>代表了在一个输入参数上需要进行的操作.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println(<span class="string">"Hello, "</span> + p.firstName);</div><div class="line">greeter.accept(<span class="keyword">new</span> Person(<span class="string">"Luke"</span>, <span class="string">"Skywalker"</span>));</div></pre></td></tr></table></figure></p>
<h3 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h3><p><code>Comparator</code>在之前的 Java 版本就已经被熟知，Java 8 在这个接口中增加了多个默认方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);</div><div class="line"></div><div class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">"John"</span>, <span class="string">"Doe"</span>);</div><div class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">"Alice"</span>, <span class="string">"Wonderland"</span>);</div><div class="line"></div><div class="line">comparator.compare(p1, p2);             <span class="comment">// &gt; 0</span></div><div class="line">comparator.reversed().compare(p1, p2);  <span class="comment">// &lt; 0</span></div></pre></td></tr></table></figure></p>
<h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><p><code>Optional</code>并非是一个函数式接口，但却是一个精巧的工具接口，用来防止<code>NullPointerException</code>，这个概念对于下一部分显得很重要，所以我们在这快速浏览一下<code>Optional</code>是如何工作的。<br><code>Optional</code>是一个简单的值容器，这个值可以是 null，也可以是 non-null 的。考虑一个方法可能返回一个 non-null 值的结果，也有可能返回一个空值。在 Java 8中，为了不直接返回 null，你可以返回一个<code>Optional</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Optional&lt;String&gt; optional = Optional.of(<span class="string">"bam"</span>);</div><div class="line"></div><div class="line">optional.isPresent();           <span class="comment">// true</span></div><div class="line">optional.get();                 <span class="comment">// "bam"</span></div><div class="line">optional.orElse(<span class="string">"fallback"</span>);    <span class="comment">// "bam"</span></div><div class="line"></div><div class="line">optional.ifPresent((s) -&gt; System.out.println(s.charAt(<span class="number">0</span>)));     <span class="comment">// "b"</span></div></pre></td></tr></table></figure></p>
<h2 id="Streams"><a href="#Streams" class="headerlink" title="Streams"></a>Streams</h2><p><code>java.util.Stream</code>代表了可以在其上面执行一个或多个操作的元素序列。流操作是中间或者完结操作。完结操作会返回一个某种类型的值，而中间操作会返回流本身，因此你可以连续链接多个方法的调用。Stream 是在一个源的基础上创建出来的，例如<code>java.util.Collection</code>中的 lists 或 sets（不支持 maps）。流操作可以被顺序或者并行执行。<br>让我们先来了解下序列流是如何工作的，首先，我们通过字符串列表的形式创建一个示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; stringCollection = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">stringCollection.add(<span class="string">"ddd2"</span>);</div><div class="line">stringCollection.add(<span class="string">"aaa2"</span>);</div><div class="line">stringCollection.add(<span class="string">"bbb1"</span>);</div><div class="line">stringCollection.add(<span class="string">"aaa1"</span>);</div><div class="line">stringCollection.add(<span class="string">"bbb3"</span>);</div><div class="line">stringCollection.add(<span class="string">"ccc"</span>);</div><div class="line">stringCollection.add(<span class="string">"bbb2"</span>);</div><div class="line">stringCollection.add(<span class="string">"ddd1"</span>);</div></pre></td></tr></table></figure></p>
<p>Java 8 中的集合已被拓展，因此你可以直接调用<code>Collection.stream()·</code>或<code>Collection.parallelStream()</code>来创建流。接下来的部分将会解释最常用的流操作。</p>
<h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><p>Filter 接受一个 predicate 类型的接口来过滤流中的元素。该操作是一个中间操作，因此它允许我们在返回结果的时候再调用其他流操作（forEach）。ForEach 接受一个 Consumer 类型的接口变量，用来执行对多虑的流中的每一个元素的操作。ForEach是一个完结操作，并且不返回流，因此我们不能再调用其他的流操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">stringCollection</div><div class="line">    .stream()</div><div class="line">    .filter((s) -&gt; s.startsWith(<span class="string">"a"</span>))</div><div class="line">    .forEach(System.out::println);</div><div class="line"></div><div class="line"><span class="comment">// "aaa2", "aaa1"</span></div></pre></td></tr></table></figure></p>
<h3 id="Sorted"><a href="#Sorted" class="headerlink" title="Sorted"></a>Sorted</h3><p>Sorted 是一个中间操作，其返回一个流排序后的视图，流中的元素默认按照自然顺序进行排序，除非你指定了一个<code>Comparator</code>接口来重定义排序规则。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">stringCollection</div><div class="line">    .stream()</div><div class="line">    .sorted()</div><div class="line">    .filter((s) -&gt; s.startsWith(<span class="string">"a"</span>))</div><div class="line">    .forEach(System.out::println);</div><div class="line"></div><div class="line"><span class="comment">// "aaa1", "aaa2"</span></div></pre></td></tr></table></figure></p>
<p>需要注意的是，<code>sorted</code>只是创建了流排序后的视图，并没有操作操作集合，集合中元素的顺序是没有改变的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">System.out.println(stringCollection);</div><div class="line"><span class="comment">// ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1</span></div></pre></td></tr></table></figure></p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>中间操作<code>map</code>通过特定的接口将每个元素转换为另一个对象，下面的例子将每一个字符串转换为全为大写的字符串。当然，你可以使用<code>map</code>将每一个对象转换为其他类型。对于带泛型结果的流对象，具体的类型还要由传递给 map 的泛型方法来决定。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">stringCollection</div><div class="line">    .stream()</div><div class="line">    .map(String::toUpperCase)</div><div class="line">    .sorted((a, b) -&gt; b.compareTo(a))</div><div class="line">    .forEach(System.out::println);</div><div class="line"></div><div class="line"><span class="comment">// "DDD2", "DDD1", "CCC", "BBB3", "BBB2", "AAA2", "AAA1"</span></div></pre></td></tr></table></figure></p>
<h3 id="Match"><a href="#Match" class="headerlink" title="Match"></a>Match</h3><p>有多种匹配操作可以用来检查某一种规则是否与流对象相匹配。所有的匹配操作都是完结操作，并且返回一个 boolean 类型的结果。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">boolean</span> anyStartsWithA =</div><div class="line">    stringCollection</div><div class="line">        .stream()</div><div class="line">        .anyMatch((s) -&gt; s.startsWith(<span class="string">"a"</span>));</div><div class="line"></div><div class="line">System.out.println(anyStartsWithA);      <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">boolean</span> allStartsWithA =</div><div class="line">    stringCollection</div><div class="line">        .stream()</div><div class="line">        .allMatch((s) -&gt; s.startsWith(<span class="string">"a"</span>));</div><div class="line"></div><div class="line">System.out.println(allStartsWithA);      <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="keyword">boolean</span> noneStartsWithZ =</div><div class="line">    stringCollection</div><div class="line">        .stream()</div><div class="line">        .noneMatch((s) -&gt; s.startsWith(<span class="string">"z"</span>));</div><div class="line"></div><div class="line">System.out.println(noneStartsWithZ);      <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<h3 id="Count"><a href="#Count" class="headerlink" title="Count"></a>Count</h3><p>Count 是一个完结操作，它返回一个 long 类型数值，用来标识流对象中包含的元素数量。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">long</span> startsWithB =</div><div class="line">    stringCollection</div><div class="line">        .stream()</div><div class="line">        .filter((s) -&gt; s.startsWith(<span class="string">"b"</span>))</div><div class="line">        .count();</div><div class="line"></div><div class="line">System.out.println(startsWithB);    <span class="comment">// 3</span></div></pre></td></tr></table></figure></p>
<h3 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h3><p>这个完结操作通过给定的函数来对流元素进行削减操作，该缩减操作的结果保存在<code>Optional</code>变量中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Optional&lt;String&gt; reduced =</div><div class="line">    stringCollection</div><div class="line">        .stream()</div><div class="line">        .sorted()</div><div class="line">        .reduce((s1, s2) -&gt; s1 + <span class="string">"#"</span> + s2);</div><div class="line"></div><div class="line">reduced.ifPresent(System.out::println);</div><div class="line"><span class="comment">// "aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2"</span></div></pre></td></tr></table></figure></p>
<h2 id="Parallel-Streams"><a href="#Parallel-Streams" class="headerlink" title="Parallel Streams"></a>Parallel Streams</h2><p>正如上面提到的，stream 可以是顺序的也可以是并行的。顺序操作通过单线程执行，而并行操作通过多线程执行。<br>下面的例子说明了使用并行流提高运行效率是多么的容易。<br>首先我们创建一个包含不同元素的列表：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> max = <span class="number">1000000</span>;</div><div class="line">List&lt;String&gt; values = <span class="keyword">new</span> ArrayList&lt;&gt;(max);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</div><div class="line">    UUID uuid = UUID.randomUUID();</div><div class="line">    values.add(uuid.toString());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在我们测量一下对这个集合进行排序需要花的时间。</p>
<ul>
<li>Sequential Sort</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">long</span> t0 = System.nanoTime();</div><div class="line"></div><div class="line"><span class="keyword">long</span> count = values.stream().sorted().count();</div><div class="line">System.out.println(count);</div><div class="line"></div><div class="line"><span class="keyword">long</span> t1 = System.nanoTime();</div><div class="line"></div><div class="line"><span class="keyword">long</span> millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);</div><div class="line">System.out.println(String.format(<span class="string">"sequential sort took: %d ms"</span>, millis));</div><div class="line"></div><div class="line"><span class="comment">// sequential sort took: 899 ms</span></div></pre></td></tr></table></figure>
<ul>
<li>Parallel Sort</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">long</span> t0 = System.nanoTime();</div><div class="line"></div><div class="line"><span class="keyword">long</span> count = values.parallelStream().sorted().count();</div><div class="line">System.out.println(count);</div><div class="line"></div><div class="line"><span class="keyword">long</span> t1 = System.nanoTime();</div><div class="line"></div><div class="line"><span class="keyword">long</span> millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);</div><div class="line">System.out.println(String.format(<span class="string">"parallel sort took: %d ms"</span>, millis));</div><div class="line"></div><div class="line"><span class="comment">// parallel sort took: 472 ms</span></div></pre></td></tr></table></figure>
<p>两个代码片段几乎一样，但是使用并行操作来排序的效率提高了接近一半，而你需要做得就仅是将<code>stream</code>替换为<code>parallelStream</code></p>
<h2 id="Map-1"><a href="#Map-1" class="headerlink" title="Map"></a>Map</h2><p>正如前面提到的，map 是不支持流操作的。<code>Map</code>接口本身没有可用的<code>stream()</code>方法，但是你可以根据键-值对或项通过<code>map.keySet().stream</code>，<code>map.values().stream()</code>和<code>map.entrySet().stream()</code>来创建指定的流。<br>此外，map 支持多种新的、有用的方法来处理常规任务。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">    map.putIfAbsent(i, <span class="string">"val"</span> + i);</div><div class="line">&#125;</div><div class="line"></div><div class="line">map.forEach((id, val) -&gt; System.out.println(val));</div></pre></td></tr></table></figure></p>
<p>上面的代码是自解释的，<code>putIfAbsent</code>防止我们写入额外的空值检查，<code>forEach</code>接受一个 Consumer 为 map 中的每一个值进行操作。<br>下面的例子说明了如何利用函数来计算 map 上的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">map.computeIfPresent(<span class="number">3</span>, (num, val) -&gt; val + num);</div><div class="line">map.get(<span class="number">3</span>);             <span class="comment">// val33</span></div><div class="line"></div><div class="line">map.computeIfPresent(<span class="number">9</span>, (num, val) -&gt; <span class="keyword">null</span>);</div><div class="line">map.containsKey(<span class="number">9</span>);     <span class="comment">// false</span></div><div class="line"></div><div class="line">map.computeIfAbsent(<span class="number">23</span>, num -&gt; <span class="string">"val"</span> + num);</div><div class="line">map.containsKey(<span class="number">23</span>);    <span class="comment">// true</span></div><div class="line"></div><div class="line">map.computeIfAbsent(<span class="number">3</span>, num -&gt; <span class="string">"bam"</span>);</div><div class="line">map.get(<span class="number">3</span>);             <span class="comment">// val33</span></div></pre></td></tr></table></figure></p>
<p>接下来，我们学习如何删除给定键的条目，只有当前键值映射到给定值时，才能删除指定条目<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">map.remove(<span class="number">3</span>, <span class="string">"val3"</span>);</div><div class="line">map.get(<span class="number">3</span>);             <span class="comment">// val33</span></div><div class="line"></div><div class="line">map.remove(<span class="number">3</span>, <span class="string">"val33"</span>);</div><div class="line">map.get(<span class="number">3</span>);             <span class="comment">// null</span></div></pre></td></tr></table></figure></p>
<p>另一个有用的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">map.getOrDefault(<span class="number">42</span>, <span class="string">"not found"</span>);  <span class="comment">// not found</span></div></pre></td></tr></table></figure></p>
<p>合并一个 map 的条目是很简单的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">map.merge(<span class="number">9</span>, <span class="string">"val9"</span>, (value, newValue) -&gt; value.concat(newValue));</div><div class="line">map.get(<span class="number">9</span>);             <span class="comment">// val9</span></div><div class="line"></div><div class="line">map.merge(<span class="number">9</span>, <span class="string">"concat"</span>, (value, newValue) -&gt; value.concat(newValue));</div><div class="line">map.get(<span class="number">9</span>);             <span class="comment">// val9concat</span></div></pre></td></tr></table></figure></p>
<p>如果不存在该键值的条目，合并或者将键/值放入 map 中，或者调用合并函数来更改现有值。</p>
<h2 id="日期API"><a href="#日期API" class="headerlink" title="日期API"></a>日期API</h2><p>Java 8 在<code>java.time</code>包下包含了全新的日期和时间 API，这个新的日期 API 与 <a href="http://www.joda.org/joda-time/" target="_blank" rel="external">Joda-Time 库</a>相似，但不完全一样。下面的例子涵盖了大部分新的 API。</p>
<h3 id="Clock"><a href="#Clock" class="headerlink" title="Clock"></a>Clock</h3><p>Clock 提供了对当前日期和时间的访问，Clocks 知道当前时区，可以使用它替代<code>System.currentTimeMillis()</code>来获取当前的毫秒时间。时间线上的某一时刻也由类<code>Instant</code>表示，Instants 可以用来创建遗留的<code>java.util.Date</code>对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Clock clock = Clock.systemDefaultZone();</div><div class="line"><span class="keyword">long</span> millis = clock.millis();</div><div class="line"></div><div class="line">Instant instant = clock.instant();</div><div class="line">Date legacyDate = Date.from(instant);   <span class="comment">// legacy java.util.Date</span></div></pre></td></tr></table></figure></p>
<h3 id="Timezones"><a href="#Timezones" class="headerlink" title="Timezones"></a>Timezones</h3><p>Timezone 由一个<code>ZoneId</code>来表示，他们可以通过静态工厂方法获得。时区定义了某一时刻和当地日期、时间之间转换的偏移量。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">System.out.println(ZoneId.getAvailableZoneIds());</div><div class="line"><span class="comment">// prints all available timezone ids</span></div><div class="line"></div><div class="line">ZoneId zone1 = ZoneId.of(<span class="string">"Europe/Berlin"</span>);</div><div class="line">ZoneId zone2 = ZoneId.of(<span class="string">"Brazil/East"</span>);</div><div class="line">System.out.println(zone1.getRules());</div><div class="line">System.out.println(zone2.getRules());</div><div class="line"></div><div class="line"><span class="comment">// ZoneRules[currentStandardOffset=+01:00]</span></div><div class="line"><span class="comment">// ZoneRules[currentStandardOffset=-03:00]</span></div></pre></td></tr></table></figure></p>
<h3 id="LocalTime"><a href="#LocalTime" class="headerlink" title="LocalTime"></a>LocalTime</h3><p>LocalTime 表示了一个没有指定时区的时间，例如 10 p.m 或者 17：30：15。下面的例子为上面定义的时区创建了两个本地时间，然后我们比较两个时间，并计算它们之间的小时和分钟之间的不同。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">LocalTime now1 = LocalTime.now(zone1);</div><div class="line">LocalTime now2 = LocalTime.now(zone2);</div><div class="line"></div><div class="line">System.out.println(now1.isBefore(now2));  <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="keyword">long</span> hoursBetween = ChronoUnit.HOURS.between(now1, now2);</div><div class="line"><span class="keyword">long</span> minutesBetween = ChronoUnit.MINUTES.between(now1, now2);</div><div class="line"></div><div class="line">System.out.println(hoursBetween);       <span class="comment">// -3</span></div><div class="line">System.out.println(minutesBetween);     <span class="comment">// -239</span></div></pre></td></tr></table></figure></p>
<p><code>LocalTime</code>带有多种工厂方法，以简化新实例的创建，包括对时间字符串进行解析操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">LocalTime late = LocalTime.of(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>);</div><div class="line">System.out.println(late);       <span class="comment">// 23:59:59</span></div><div class="line"></div><div class="line">DateTimeFormatter germanFormatter =</div><div class="line">    DateTimeFormatter</div><div class="line">        .ofLocalizedTime(FormatStyle.SHORT)</div><div class="line">        .withLocale(Locale.GERMAN);</div><div class="line"></div><div class="line">LocalTime leetTime = LocalTime.parse(<span class="string">"13:37"</span>, germanFormatter);</div><div class="line">System.out.println(leetTime);   <span class="comment">// 13:37</span></div></pre></td></tr></table></figure></p>
<h3 id="LocalDate"><a href="#LocalDate" class="headerlink" title="LocalDate"></a>LocalDate</h3><p>LocalDate 表示不同的日期，例如2014-03-11。它是不可变的，并且与<code>LocalTime</code>完全类似。下面的例子演示了如何通过加减日、月、年来计算新日期。需要注意的是，每一个操作都会返回一个新实例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">LocalDate today = LocalDate.now();</div><div class="line">LocalDate tomorrow = today.plus(<span class="number">1</span>, ChronoUnit.DAYS);</div><div class="line">LocalDate yesterday = tomorrow.minusDays(<span class="number">2</span>);</div><div class="line"></div><div class="line">LocalDate independenceDay = LocalDate.of(<span class="number">2014</span>, Month.JULY, <span class="number">4</span>);</div><div class="line">DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();</div><div class="line">System.out.println(dayOfWeek);    <span class="comment">// FRIDAY</span></div></pre></td></tr></table></figure></p>
<p>从字符串中解析 LocalDate 就跟解析 LocalTime 一样简单：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">DateTimeFormatter germanFormatter =</div><div class="line">    DateTimeFormatter</div><div class="line">        .ofLocalizedDate(FormatStyle.MEDIUM)</div><div class="line">        .withLocale(Locale.GERMAN);</div><div class="line"></div><div class="line">LocalDate xmas = LocalDate.parse(<span class="string">"24.12.2014"</span>, germanFormatter);</div><div class="line">System.out.println(xmas);   <span class="comment">// 2014-12-24</span></div></pre></td></tr></table></figure></p>
<h3 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a>LocalDateTime</h3><p>LocalDateTIme 表示的是日期-时间。它将日期和时间组合成一个实例。<code>LocalDateTime</code>是不可变的，与 <code>LocalTime</code>和<code>LocalDate</code>工作原理类似。我们可以利用方法去获取日期时间中的某些字段值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">LocalDateTime sylvester = LocalDateTime.of(<span class="number">2014</span>, Month.DECEMBER, <span class="number">31</span>, <span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>);</div><div class="line"></div><div class="line">DayOfWeek dayOfWeek = sylvester.getDayOfWeek();</div><div class="line">System.out.println(dayOfWeek);      <span class="comment">// WEDNESDAY</span></div><div class="line"></div><div class="line">Month month = sylvester.getMonth();</div><div class="line">System.out.println(month);          <span class="comment">// DECEMBER</span></div><div class="line"></div><div class="line"><span class="keyword">long</span> minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);</div><div class="line">System.out.println(minuteOfDay);    <span class="comment">// 1439</span></div></pre></td></tr></table></figure></p>
<p>通过一个时区的附件信息可以转换为一个实例，这个实例很容易转为<code>java.util.Date</code>类型。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Instant instant = sylvester</div><div class="line">        .atZone(ZoneId.systemDefault())</div><div class="line">        .toInstant();</div><div class="line"></div><div class="line">Date legacyDate = Date.from(instant);</div><div class="line">System.out.println(legacyDate);     <span class="comment">// Wed Dec 31 23:59:59 CET 2014</span></div></pre></td></tr></table></figure></p>
<p>日期-时间的格式化类似于 Date 或 Time。我们可以使用自定义模式来取代预定义的格式进行格式化。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">DateTimeFormatter formatter =</div><div class="line">    DateTimeFormatter</div><div class="line">        .ofPattern(<span class="string">"MMM dd, yyyy - HH:mm"</span>);</div><div class="line"></div><div class="line">LocalDateTime parsed = LocalDateTime.parse(<span class="string">"Nov 03, 2014 - 07:13"</span>, formatter);</div><div class="line">String string = formatter.format(parsed);</div><div class="line">System.out.println(string);     <span class="comment">// Nov 03, 2014 - 07:13</span></div></pre></td></tr></table></figure></p>
<p>不像<code>java.text.NumberFormat</code>，<code>DateTimeFormatter</code>是不可变的并且是线程安全的。<br>了解更多有关日期格式化的信息可以参考<a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html" target="_blank" rel="external">这里</a></p>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>Java 8中的注解是可重复的，我们直接通过一个例子来了解它。<br>首先，我们定义了一个包装注解，它包括了一个实际注解的数组：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@interface</span> Hints &#123;</div><div class="line">    Hint[] value();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Repeatable</span>(Hints.class)</div><div class="line"><span class="meta">@interface</span> Hint &#123;</div><div class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Java 8 允许我们通过使用<code>@Repeatable</code>对同一类型使用多个注解</p>
<ul>
<li><p>变体一：使用注解容器（老方法）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Hints</span>(&#123;<span class="meta">@Hint</span>(<span class="string">"hint1"</span>), <span class="meta">@Hint</span>(<span class="string">"hint2"</span>)&#125;)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>变体二：使用可重复注解（新方法）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Hint</span>(<span class="string">"hint1"</span>)</div><div class="line"><span class="meta">@Hint</span>(<span class="string">"hint2"</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>使用变体2，Java 编译器隐式地对<code>@Hint</code>进行设置，这对于通过反射来读取注解信息非常重要。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Hint hint = Person.class.getAnnotation(Hint.class);</div><div class="line">System.out.println(hint);                   <span class="comment">// null</span></div><div class="line"></div><div class="line">Hints hints1 = Person.class.getAnnotation(Hints.class);</div><div class="line">System.out.println(hints1.value().length);  <span class="comment">// 2</span></div><div class="line"></div><div class="line">Hint[] hints2 = Person.class.getAnnotationsByType(Hint.class);</div><div class="line">System.out.println(hints2.length);          <span class="comment">// 2</span></div></pre></td></tr></table></figure></p>
<p>尽管我们不会在<code>Person</code>类中声明<code>@Hints</code>注解，但是它仍然可以通过<code>getAnnotation(Hint.class)</code>来读取。然后，更便利的方法是<code>getAnnotationByType</code>，它可以直接访问<code>@Hint</code>注解。<br>此外，Java 8 中关于注解的使用，其还拓展了两个新的目标：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE_PARAMETER, ElementType.TYPE_USE&#125;)</div><div class="line"><span class="meta">@interface</span> MyAnnotation &#123;&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文译自&lt;a href=&quot;https://github.com/winterbe/java8-tutorial&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java8-tutorial&lt;/a&gt;，并对其中内容进行了一些修改和补充。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://zhaoxizhang.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>&#39;test&#39;</title>
    <link href="https://zhaoxizhang.github.io/2017/08/08/test/"/>
    <id>https://zhaoxizhang.github.io/2017/08/08/test/</id>
    <published>2017-08-08T12:14:39.000Z</published>
    <updated>2017-08-09T01:53:33.445Z</updated>
    
    <content type="html"><![CDATA[<p>test</p>
<a id="more"></a>
<h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;test&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
