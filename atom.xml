<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZhaoxiZhang</title>
  <subtitle>Stay Hungry, Stay Foolish.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhaoxizhang.github.io/"/>
  <updated>2018-12-12T11:09:28.453Z</updated>
  <id>https://zhaoxizhang.github.io/</id>
  
  <author>
    <name>ZhaoxiZhang</name>
    <email>ZhaoxiCheung@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java——LinkedHashMap源码解析</title>
    <link href="https://zhaoxizhang.github.io/2018/12/12/Java-LinkedHashMap-Source-Analysis/"/>
    <id>https://zhaoxizhang.github.io/2018/12/12/Java-LinkedHashMap-Source-Analysis/</id>
    <published>2018-12-11T16:00:00.000Z</published>
    <updated>2018-12-12T11:09:28.453Z</updated>
    
    <content type="html"><![CDATA[<p>以下针对JDK 1.8版本中的<strong>LinkedHashMap</strong>进行分析。<br>对于<code>HashMap</code>的源码解析，可阅读<a href="https://www.cnblogs.com/ZhaoxiCheung/p/Java-HashMap-Source-Analysis.html" target="_blank" rel="external">Java——HashMap源码解析</a></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&nbsp;&nbsp;哈希表和链表基于<code>Map</code>接口的实现，其具有可预测的迭代顺序。此实现与<code>HashMap</code>的不同之处在于它维护了一个包括所有条目（Entry）的双向链表。相比于无序的<code>HashMap</code>，<code>LinkedHashMap</code>迭代顺序支持按插入条目顺序或者按访问条目顺序，默认迭代顺序为按插入顺序。对于相同 <u>key</u> 的重复插入，其不会改变插入顺序。<br><a id="more"></a><br>&nbsp;&nbsp;此实现可以让客户端免受由<code>HashMap</code>（和<code>Hashtable</code>）提供的未指定的，通常是混乱的排序，而对于与<code>TreeMap</code>提供的默认根据键排序的功能相比，其性能成本会更小。使用它可以生成一个与原来顺序相同的映射副本，而与原映射的实现无关：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(Map m)</span> </span>&#123;</div><div class="line">    Map copy = <span class="keyword">new</span> LinkedHashMap(m);</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果模块通过输入得到一个映射，复制这个映射，然后返回由此副本确定其顺序的结果，这种情况下这项技术特别有用（客户端通常期望返回的内容与其出现的顺序相同）。</p>
<p>&nbsp;&nbsp;<code>LinkedHashMap</code>提供一种特殊的构造方法来创建哈希表，其迭代顺序根据条目的访问顺序排序，从近期访问最少到近期访问最多的顺序（访问顺序）。这种映射的迭代顺序很适合构建 <u>LRU Cache</u>。调用<code>put</code>、<code>putIfPresent</code>、<code>get</code>、<code>getOrDefault</code>、<code>compute</code>、<code>computeIfAbsent</code>、<code>computerIfPresent</code>或者<code>merge</code>方法都算是对相应条目的访问（假定调用完成后它还存在）。<code>replace()</code>方法只有在值被替换的情况下，才算是对条目的访问。<code>putAll</code>方法以指定映射的条目集迭代器提供的键-值映射关系的顺序，为指定映射的每个映射关系生成一个条目访问。任何其他方法均不生成条目访问。特别是，collection 视图上的操作不 影响底层映射的迭代顺序。</p>
<p>&nbsp;&nbsp;可以重写<code>removeEldestEntry(Map.Entry)</code>方法来实施策略，以便在将新的条目添加到哈希表时，如果超过指定容量，自动移除旧的条目，这在实现 <u>LRU Cahce</u>的时候将非常有用。</p>
<p>&nbsp;&nbsp;这个类提供了所有可选的<code>Map</code>的操作，并且允许<code>null</code>元素。和<code>HashMap</code>一样，假定哈希函数将元素均匀分布到各个桶中，对于基本操作如<code>add</code>、<code>contains</code>和<code>remove</code>，其提供了常数时间的性能。由于增加了维护链表的开支，其性能很可能比<code>HashMap</code>稍逊一筹，不过有一点是例外的：<code>LinkedHashMap</code>的 collection 视图迭代所需时间与映射的大小（<u>size</u>）成比例，而与容量（<u>capacity</u>）无关；<code>HashMap</code>迭代时间很可能开支较大，因为它所需要的时间与其容量（<u>capacity</u>）成比例。</p>
<p>&nbsp;&nbsp;<code>LinkedHashMap</code>有两个因子影响着其性能：<strong>初始容量</strong>和<strong>负载因子</strong>。它们的定义与<code>HashMap</code>完全相同。要注意，为初始容量选择非常高的值对此类的影响比对<code>HashMap</code>要小，因为此类的迭代时间不受容量的影响。</p>
<p>&nbsp;&nbsp;<strong>值得注意的是，这个类对于<code>Map</code>接口都不是同步的。</strong>如果多个线程并发的访问一个哈希表，并且至少有一个线程对这个哈希表进行结构性更改，那么必须增添额外的同步操作。这一般通过对自然封装该映射的对象进行同步操作来完成。如果不存在这样的对象，则应该使用<code>Collections.synchronizedMap</code>方法来“包装”该哈希表。最好在创建时完成这一操作，以防止对哈希表的意外的非同步访问：<code>Map m = Collections.synchronizedMap(new LinkedHashMap(...));</code></p>
<p>&nbsp;&nbsp;对于结构性更改指任何添加或者删除一个或者多个条目，或者在按访问顺序的哈希表中影响迭代顺序的任何操作。在按插入顺序的哈希表中，仅更改已存在的 key 对应的 value 值不是结构性修改。在按访问顺序的哈希表中，仅利用<code>get</code>查询不是结构性修改。）</p>
<p>&nbsp;&nbsp;Collection（由此类的所有 collection 视图方法所返回）的 iterator 方法返回的迭代器都是快速失败的：在迭代器创建之后，如果从结构上对映射进行修改，除非通过迭代器自身的<code>remove</code>方法，其他任何时间任何方式的修改，迭代器都将抛出<code>ConcurrentModificationException</code>。因此，面对并发的修改，迭代器很快就会完全失败，而不冒将来不确定的时间发生任意不确定行为的风险。</p>
<p>&nbsp;&nbsp;注意，迭代器的快速失败行为无法得到保证，因为一般来说，不可能对是否出现不同步并发修改做出任何硬性保证。快速失败迭代器会尽最大努力抛出 <code>ConcurrentModificationException</code>。因此，为提高这类迭代器的正确性而编写一个依赖于此异常的程序是错误的做法：迭代器的快速失败行为应该仅用于检测 bug。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 根据指定的初始容量和负载因子，初始化一个空的按照插入顺序排序的 LinkedHashMap 的实例</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</div><div class="line">    accessOrder = <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 根据指定的容量和默认的负载因子（0.75），初始化一个空的按照插入顺序排序的 LinkedHashMap 的实例</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(initialCapacity);</div><div class="line">    accessOrder = <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 根据默认的容量（16）和负载因子（0.75），初始化一个空的按照插入顺序排序的 LinkedHashMap 实例</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>();</div><div class="line">    accessOrder = <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 初始化一个根据传入的映射关系并且按照插入顺序排序的 LinkedHashMap 的实例</span></div><div class="line"><span class="comment"> * 这个 LinkedHashMap 实例的负载因子为0.75，容量不小于指定的映射关系的数量的最小2次幂</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>();</div><div class="line">    accessOrder = <span class="keyword">false</span>;</div><div class="line">    putMapEntries(m, <span class="keyword">false</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 根据指定的容量、负载因子、排序模式来初始化一个空的 LinkedHashMap 的实例</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></div><div class="line"><span class="function"><span class="params">                     <span class="keyword">float</span> loadFactor,</span></span></div><div class="line"><span class="function"><span class="params">                     <span class="keyword">boolean</span> accessOrder)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</div><div class="line">    <span class="keyword">this</span>.accessOrder = accessOrder;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;从上面的构造函数可以看出来：<code>accessOrder = false</code>，如果没有特别指定排序模式，那么其将按照插入顺序来作为迭代顺序。</p>
<h3 id="三个重要的回调函数"><a href="#三个重要的回调函数" class="headerlink" title="三个重要的回调函数"></a>三个重要的回调函数</h3><p>在<code>HashMap</code>源码中，预留了三个回调函数，来让<code>LinkedHashMap</code>进行后期操作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Callbacks to allow LinkedHashMap post-actions</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; &#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K,V&gt; p)</span> </span>&#123; &#125;</div></pre></td></tr></table></figure></p>
<p>在<code>LinkedHashMap</code>中，这三个函数实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//移除节点的时候会触发回调，将节点从双向链表中删除，在调用 removeNode 函数时候会执行</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeRemoval</span><span class="params">(Node&lt;K, V&gt; e)</span> </span>&#123; <span class="comment">// unlink</span></div><div class="line">    LinkedHashMap.Entry&lt;K, V&gt; p =</div><div class="line">        (LinkedHashMap.Entry&lt;K, V&gt;)e, b = p.before, a = p.after;</div><div class="line">    p.before = p.after = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>)</div><div class="line">        head = a;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        b.after = a;</div><div class="line">    <span class="keyword">if</span> (a == <span class="keyword">null</span>)</div><div class="line">        tail = b;</div><div class="line">    <span class="keyword">else</span></div><div class="line">        a.before = b;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//新节点插入时会触发回调，根据条件判断是否移除最老的条目，在调用 compute computeIfAbsent merge putVal 函数时候会实行</span></div><div class="line"><span class="comment">//实现 LruCache 的时候会用到这个函数</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeInsertion</span><span class="params">(<span class="keyword">boolean</span> evict)</span> </span>&#123; <span class="comment">// possibly remove eldest</span></div><div class="line">    LinkedHashMap.Entry&lt;K, V&gt; first;</div><div class="line">    <span class="keyword">if</span> (evict &amp;&amp; (first = head) != <span class="keyword">null</span> &amp;&amp; removeEldestEntry(first)) &#123;</div><div class="line">        K key = first.key;</div><div class="line">        removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//将节点放置链表尾，在调用 putVal 函数时会执行，保证最近访问节点在链表尾部</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K, V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></div><div class="line">    LinkedHashMap.Entry&lt;K, V&gt; last;</div><div class="line">    <span class="comment">//accessOrder为 true表示按照访问顺序排序，并且此时的键值对不在链表尾部</span></div><div class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</div><div class="line">        LinkedHashMap.Entry&lt;K, V&gt; p =</div><div class="line">            (LinkedHashMap.Entry&lt;K, V&gt;)e, b = p.before, a = p.after;</div><div class="line">        p.after = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</div><div class="line">            head = a;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            b.after = a;</div><div class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</div><div class="line">            a.before = b;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            last = b;</div><div class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)</div><div class="line">            head = p;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            p.before = last;</div><div class="line">            last.after = p;</div><div class="line">        &#125;</div><div class="line">        tail = p;</div><div class="line">        ++modCount;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从上面三个回调函数可以看出，其主要是在对条目进行操作的时候触发来维护双向链表。另外值得一提的是<code>afterNodeInsertion</code>和<code>removeEldestEntry</code>函数，在构建 <u>LruCache</u> 时将非常有用。对于<code>removeEldestEntry</code>，其默认返回<code>false</code>，因此默认情况下不会删除最旧的元素：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span>    eldest 哈希表中最近插入的条目，或者如果迭代顺序是按照访问顺序排序，则是最近最少访问的条目。</span></div><div class="line"><span class="comment"> *                  如果这个方法返回 true，则这是将被删除的条目。如果在 put 或 putAll 调用之前哈希表为空时，触发此调用，</span></div><div class="line"><span class="comment"> *                  则这将是刚插入的条目;换句话说，如果哈希表包含单个条目，则最老的条目也是最新的。</span></div><div class="line"><span class="comment"> * <span class="doctag">@return</span>   返回 true 表明将删除最老的条目</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K, V&gt; eldest)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果需要删除最旧条目，则返回true。在将新条目插入后，<code>put</code>和<code>putAll</code>将调用此方法。它为实现者提供了在每次添加新条目时删除最旧条目的机会。如果用来实现缓存，则此选项非常有用：它允许哈希表通过删除过时条目来减少内存消耗。<br>示例使用：重写这个函数实现，以下例子将允许在增长到100个条目时，然后在每次添加新条目时删除最旧的条目，保持100个条目的稳定状态。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ENTRIES = <span class="number">100</span>;</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry eldest)</span> </span>&#123;</div><div class="line">   <span class="keyword">return</span> size() &gt; MAX_ENTRIES;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>此方法通常不通过重写来修改哈希表，而是通过返回值来判断是否对哈希表进行修改。当然，此方法允许直接修改哈希表，但如果它这样做，则必须返回false（表示哈希表不应尝试任何进一步的修改）。如果在此方法中修改哈希表后返回 true，那么对于结果是未指定。</p>
<h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p>&nbsp;&nbsp;<code>LinkedHashMap</code>直接使用了<code>HashMap</code>的<code>put</code>函数，但重写了<code>newNode</code>、<code>afterNodeAccess</code>和<code>afterNodeInsertion</code>方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</div><div class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</div><div class="line">        <span class="keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</div><div class="line">    <span class="comment">//将节点放置链表尾部</span></div><div class="line">    linkNodeLast(p);</div><div class="line">    <span class="keyword">return</span> p;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 将新增节点放置链表尾部</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</div><div class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</div><div class="line">    tail = p;</div><div class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>)</div><div class="line">        head = p;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        p.before = last;</div><div class="line">        last.after = p;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>&nbsp;&nbsp;同样的，<code>LinkedHashMap</code>仍然直接使用了<code>HashMap</code>的<code>remove</code>函数，只是对<code>afterNodeRemoval</code>回调函数进行了重写。对于<code>afterNodeRemoval</code>函数上面已经分析过了。</p>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 返回指定 key 所对应的 value 值，当不存在指定的 key 时，返回 null。</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * 当返回 null 的时候并不表明哈希表中不存在这种关系的映射，有可能对于指定的 key，其对应的值就是 null。</span></div><div class="line"><span class="comment"> * 因此可以通过 containsKey 来区分这两种情况。</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt; e;</div><div class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span> (accessOrder)</div><div class="line">        afterNodeAccess(e);</div><div class="line">    <span class="keyword">return</span> e.value;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;与<code>HashMap</code>相比，其多了一步对 <u>accessOrder</u> 的判断来维护链表，当指定迭代顺序按照访问顺序排序时，<code>get</code>操作表明对指定的条目进行了一次访问，那么此条目应该移到链表尾部。对于<code>afterNodeAccess</code>在上面已经分析过了，值得注意的是，在调用<code>afterNodeAccess</code>时，会修改 <u>modeCount</u>，所以当你正在<code>accessOrder = true</code>的模式下迭代<code>LinkedHashMap</code>时，如果同时查询访问数据，会导致 <u>fail-fast</u>，因为迭代的顺序已经变了。</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>&nbsp;&nbsp;对于<code>LinkedHashMap</code>其与<code>HashMap</code>还有一些不同，由于<code>LinkedHashMap</code>维护一个双向链表，因此在判断哈希表中是否存储着某个键值对的时候，不需要在整个数组桶中查找，而只需要对链表遍历即可，这也是<code>LinkedHashMap</code>的其中一处优化。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</div><div class="line">    <span class="keyword">for</span> (LinkedHashMap.Entry&lt;K, V&gt; e = head; e != <span class="keyword">null</span>; e = e.after) &#123;</div><div class="line">        V v = e.value;</div><div class="line">        <span class="keyword">if</span> (v == value || (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="实现-LruCache"><a href="#实现-LruCache" class="headerlink" title="实现 LruCache"></a>实现 LruCache</h2><p>在 LeetCode 有一道题——<a href="https://leetcode.com/problems/lru-cache/" target="_blank" rel="external">Lru Cache</a>：设计和实现一个  LRU (最近最少使用) 缓存机制，那么就可以利用<code>LinkedHashMap</code>可选的迭代顺序——按访问顺序的模式来进行实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity;</div><div class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; cache;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.capacity = capacity;</div><div class="line">        <span class="keyword">this</span>.cache = <span class="keyword">new</span> java.util.LinkedHashMap&lt;Integer, Integer&gt; (capacity, <span class="number">0.75f</span>, <span class="keyword">true</span>) &#123;</div><div class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;Integer, Integer&gt; eldest)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> size() &gt; capacity;</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (cache.containsKey(key)) &#123;</div><div class="line">            <span class="keyword">return</span> cache.get(key);</div><div class="line">        &#125; <span class="keyword">else</span></div><div class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">        cache.put(key, value);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></div><div class="line"><span class="comment"> * LRUCache obj = new LRUCache(capacity);</span></div><div class="line"><span class="comment"> * int param_1 = obj.get(key);</span></div><div class="line"><span class="comment"> * obj.put(key,value);</span></div><div class="line"><span class="comment"> */</span></div></pre></td></tr></table></figure></p>
<p>当然，如果觉得直接使用<code>LinkedHashMap</code>的方式太过取巧，我们仍可以借鉴<code>LinkedHashMap</code>的思想来进行实现——使用 <u>HashMap 和 双向链表</u> 的组合来实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</div><div class="line">        Integer key;</div><div class="line">        Integer value;</div><div class="line">        Node prev;</div><div class="line">        Node next;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(Integer key, Integer value)</span></span>&#123;</div><div class="line">            <span class="keyword">this</span>.key = key;</div><div class="line">            <span class="keyword">this</span>.value = value;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Map&lt;Integer, Node&gt;map;</div><div class="line">    Node head;</div><div class="line">    Node tail;</div><div class="line">    <span class="keyword">int</span> size;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</div><div class="line">        size = capacity;</div><div class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;(capacity);</div><div class="line">        head = <span class="keyword">new</span> Node(<span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">        tail = <span class="keyword">new</span> Node(<span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">        head.next = tail;</div><div class="line">        tail.prev = head;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</div><div class="line">        Node node = map.get(key);</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != node)&#123;</div><div class="line">            map.remove(node.key);</div><div class="line"></div><div class="line">            node.prev.next = node.next;</div><div class="line">            node.next.prev = node.prev;</div><div class="line"></div><div class="line">            appendTail(node);</div><div class="line">            map.put(key, node);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> value = <span class="keyword">null</span> == node ? -<span class="number">1</span> : node.value;</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</div><div class="line">        Node node = map.get(key);</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != node)&#123;</div><div class="line">            map.remove(node.key);</div><div class="line"></div><div class="line">            node.prev.next = node.next;</div><div class="line">            node.next.prev = node.prev;</div><div class="line"></div><div class="line">            node.value = value;</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (map.size() == size)&#123;</div><div class="line">            Node tmp = head.next;</div><div class="line">            map.remove(tmp.key);</div><div class="line"></div><div class="line">            head.next = tmp.next;</div><div class="line">            tmp.next.prev = head;</div><div class="line"></div><div class="line">            tmp = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == node)   node = <span class="keyword">new</span> Node(key, value);</div><div class="line">        appendTail(node);</div><div class="line">        map.put(key, node);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(Node node)</span></span>&#123;</div><div class="line">        tail.prev.next = node;</div><div class="line">        node.prev = tail.prev;</div><div class="line">        node.next = tail;</div><div class="line">        tail.prev = node;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></div><div class="line"><span class="comment"> * LRUCache obj = new LRUCache(capacity);</span></div><div class="line"><span class="comment"> * int param_1 = obj.get(key);</span></div><div class="line"><span class="comment"> * obj.put(key,value);</span></div><div class="line"><span class="comment"> */</span></div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下针对JDK 1.8版本中的&lt;strong&gt;LinkedHashMap&lt;/strong&gt;进行分析。&lt;br&gt;对于&lt;code&gt;HashMap&lt;/code&gt;的源码解析，可阅读&lt;a href=&quot;https://www.cnblogs.com/ZhaoxiCheung/p/Java-HashMap-Source-Analysis.html&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java——HashMap源码解析&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;哈希表和链表基于&lt;code&gt;Map&lt;/code&gt;接口的实现，其具有可预测的迭代顺序。此实现与&lt;code&gt;HashMap&lt;/code&gt;的不同之处在于它维护了一个包括所有条目（Entry）的双向链表。相比于无序的&lt;code&gt;HashMap&lt;/code&gt;，&lt;code&gt;LinkedHashMap&lt;/code&gt;迭代顺序支持按插入条目顺序或者按访问条目顺序，默认迭代顺序为按插入顺序。对于相同 &lt;u&gt;key&lt;/u&gt; 的重复插入，其不会改变插入顺序。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java——源码分析" scheme="https://zhaoxizhang.github.io/tags/Java%E2%80%94%E2%80%94%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>Java——ArrayList源码解析</title>
    <link href="https://zhaoxizhang.github.io/2018/11/07/Java-ArrayList-Source-Analysis/"/>
    <id>https://zhaoxizhang.github.io/2018/11/07/Java-ArrayList-Source-Analysis/</id>
    <published>2018-11-06T16:00:00.000Z</published>
    <updated>2018-11-06T16:39:50.099Z</updated>
    
    <content type="html"><![CDATA[<p>以下针对JDK 1.8版本中的<strong>ArrayList</strong>进行分析。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;<code>ArrayList</code>基于<code>List</code>接口实现的大小可变的数组。其实现了所有可选的<code>List</code>操作，并且元素允许为任意类型，包括<code>null</code>元素。除了实现<code>List</code>接口，此类还提供了操作内部用于存储列表数组大小的方法（这个类除了没有实现同步外，功能基本与<code>Vector</code>一致）。<br><a id="more"></a><br>&nbsp;&nbsp;&nbsp;&nbsp;每个<code>ArrayList</code>实例都有一个容量。容量是用于存储列表中元素的数组的大小。它始终至少与列表大小一样大。随着元素添加到<code>ArrayList</code>，其容量会自动增加。除了添加元素具有恒定的摊销时间成本这一事实之外，增长策略并没有详细指出。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;我们在添加大容量数据的时候可以使用<code>ensureCapacity</code>方法来主动扩容，这可以减少自动扩容的次数。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;值得注意的是，这些实现都不是同步的。因此，当多个线程并发访问一个<code>ArrayList</code>实例并且至少有一个线程对这个实例进行结构性调整的时候，必须在外部额外实现同步（对于结构性调整，主要指增加或删除一个或多个元素，更精确的说，就是对这个列表的大小进行了调整，对于更改元素的数值并非是结构性调整）。这通常通过在自然封装列表的某个对象上进行同步来完成。如果不存在此类对象，则应使用<code>Collections.synchronizedList</code>方法“包装”该列表。这最好在创建时完成，以防止意外地不同步访问列表：<code>List list = Collections.synchronizedList(new ArrayList(...));</code></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;注意，迭代器的快速失败行为无法得到保证，因为一般来说，不可能对是否出现不同步并发修改做出任何硬性保证。快速失败迭代器会尽最大努力抛出<code>ConcurrentModificationException</code>。因此，为提高这类迭代器的正确性而编写一个依赖于此异常的程序是错误的做法：迭代器的快速失败行为应该仅用于检测 bug。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="主要字段"><a href="#主要字段" class="headerlink" title="主要字段"></a><span id="主要字段">主要字段</span></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 默认初始容量</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 用于ArrayList空实例的共享空数组实例</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 用于默认大小空实例的共享空数组实例。我们将this（DEFAULTCAPACITY_EMPTY_ELEMENTDATA）</span></div><div class="line"><span class="comment"> * 和EMPTY_ELEMENTDATA区别开来，以便在添加第一个元素时知道数组大小要扩容为多少多少。</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 存储 ArrayList 元素的数组缓冲区。ArrayList 的容量是此数组缓冲区的长度。</span></div><div class="line"><span class="comment"> * 当第一个元素添加进空数组时候 elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA 将会被扩容至 DEFAULT_CAPACITY</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * ArrayList的数组大小（ArrayList包含的元素个数</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</div></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;注意此处的<code>elementData</code>字段是用的<code>transient</code>修饰的以及对于空实例有<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>和<code>EMPTY_ELEMENTDATA</code>两个共享空数组实例，下面会对提到的这些注意点进行分析。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 根据指定的容量初始化空的列表，注意当容量为 0 时，使用的是 EMPTY_ELEMENTDATA</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</div><div class="line">                                           initialCapacity);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 初始化容量为 10 的空列表</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Constructs a list containing the elements of the specified</span></div><div class="line"><span class="comment"> * collection, in the order they are returned by the collection's</span></div><div class="line"><span class="comment"> * iterator.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">    elementData = c.toArray();</div><div class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></div><div class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</div><div class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// replace with empty array.</span></div><div class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;注意到对于无参构造器使用的是<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>，而对于带参构造器，当 <u>initialCapacity</u> 为0时，使用的是<code>EMPTY_ELEMENTDATA</code>；另外，在无参构造器中的注释——“初始化容量为10的空列表”，我们不禁有以下疑惑：</p>
<ul>
<li><code>EMPTY_ELEMENTDATA</code>和<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>都是空的对象数组，为什么在构造器中要对其进行区分</li>
<li>无参构造器中，只是把空的对象数组赋值给了<code>elementData</code>，为什么注释称声明了长度为10的空数组</li>
</ul>
<p>对于以上问题，将在<strong>存储和扩容</strong>部分进行讲解。</p>
<h3 id="存储和扩容"><a href="#存储和扩容" class="headerlink" title="存储和扩容"></a>存储和扩容</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 增加 ArrayList 实例的容量，确保 ArrayList 实例能存储 minCapacity 个元素</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</div><div class="line">        <span class="comment">// any size if not default element table</span></div><div class="line">        ? <span class="number">0</span></div><div class="line">        <span class="comment">// larger than default for default empty table. It's already</span></div><div class="line">        <span class="comment">// supposed to be at default size.</span></div><div class="line">        : DEFAULT_CAPACITY;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</div><div class="line">        ensureExplicitCapacity(minCapacity);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;当ArrayList实例是个空列表并且 <code>elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>时，<u>minExpand</u> 设置为<code>DEFAULT_CAPACITY</code>(10)，此时如果 <u>minCapacity</u> 小于 <u>minExpand</u>，那么不马上进行扩容操作，在进行<code>add</code>操作时候，会初始化一个容量为 10 的空列表，这样不仅符合无参构造器中的注释，并且保证了 ArrayList 实例能够存储 <u>minCapacity</u> 个元素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</div><div class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ensureExplicitCapacity(minCapacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;在<code>add</code>操作内部，会调用这个<strong>私有</strong>方法来确保有足够的容量来放置元素。注意，这个函数一开始就对 <u>elementData</u> 进行判断是否为 <code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>，如果是的话，证明是无参构造器初始化的实例，在下一步会初始化一个容量为 10 的空列表，符合无参构造器中的注释，其实就是一个延迟初始化的技巧。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    modCount++;</div><div class="line"></div><div class="line">    <span class="comment">// 扩容操作</span></div><div class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</div><div class="line">        grow(minCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 允许分配的最大数组大小</span></div><div class="line"><span class="comment"> *一些 VM 会在数组头部储存头数据，试图尝试创建一个比 Integer.MAX_VALUE - 8 大的数组可能会产生 OOM 异常。</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 增加 ArrayList 实例的容量，确保 ArrayList 实例能存储 minCapacity 个元素</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="comment">// overflow-conscious code</span></div><div class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</div><div class="line">    <span class="comment">//扩容为当前容量的 1.5 倍</span></div><div class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</div><div class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</div><div class="line">        newCapacity = minCapacity;</div><div class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</div><div class="line">        newCapacity = hugeCapacity(minCapacity);</div><div class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></div><div class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</div><div class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</div><div class="line">        Integer.MAX_VALUE :</div><div class="line">        MAX_ARRAY_SIZE;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 将指定的元素追加到此列表的末尾</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></div><div class="line">    elementData[size++] = e;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 在列表中将指定元素插入到指定位置，将其后元素都向右移动一个位置</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</div><div class="line">    <span class="comment">//检查 index 是否越界</span></div><div class="line">    rangeCheckForAdd(index);</div><div class="line"></div><div class="line">    <span class="comment">//确保有足够的容量能够添加元素</span></div><div class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></div><div class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</div><div class="line">                     size - index);</div><div class="line">    elementData[index] = element;</div><div class="line">    size++;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 将指定集合中的全部元素添加到列表尾端</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">    Object[] a = c.toArray();</div><div class="line">    <span class="keyword">int</span> numNew = a.length;</div><div class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></div><div class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</div><div class="line">    size += numNew;</div><div class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 将指定集合中的全部元素插入到列表指定的位置后面</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</div><div class="line">    rangeCheckForAdd(index);</div><div class="line"></div><div class="line">    Object[] a = c.toArray();</div><div class="line">    <span class="keyword">int</span> numNew = a.length;</div><div class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></div><div class="line"></div><div class="line">    <span class="keyword">int</span> numMoved = size - index;</div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">        System.arraycopy(elementData, index, elementData, index + numNew,</div><div class="line">                         numMoved);</div><div class="line"></div><div class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</div><div class="line">    size += numNew;</div><div class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;因此对于无参构造器的注释的疑问，到达这里就可以解答了，它确确实实初始化了一个大小为 10 的空列表，只是不是一开始就初始化，而是使用了延迟初始化的方式，在<code>add</code>的时候才进行初始化。<br>&nbsp;&nbsp;&nbsp;&nbsp;对于另一个问题，无参构造器使用<code>DEFAULTCAPACITY_EMPTY_ELEMENTDAT</code>，对于<code>new ArrayList(0);</code>使用的是<code>EMPTY_ELEMENTDATA</code>，前者是不知道需要的容量大小，后者预估元素较少。因此<code>ArrayList</code>对此做了区别，通过引用判断来区别用户行为，使用不同的扩容算法（扩容速度：无参：10-&gt;15-&gt;22…，有参且参数为0 ：0-&gt;1-&gt;2-&gt;3-&gt;4-&gt;6-&gt;9…)。另外，在 JDK 1.7 中，没有通过两个空数组来对用户行为进行区分，因此容量为 0 的话，会创建很多空数组<code>new Object[0]</code>，因此上述方式也对这种情况进行了优化。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//JDK 1.7</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>();</div><div class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</div><div class="line">                                           initialCapacity);</div><div class="line">    <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(<span class="number">10</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 从列表中删除指定位置的元素，并将其后位置的元素向左移动</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    <span class="comment">//检查是否超过数组越界</span></div><div class="line">    rangeCheck(index);</div><div class="line"></div><div class="line">    modCount++;</div><div class="line">    E oldValue = elementData(index);</div><div class="line"></div><div class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</div><div class="line">                         numMoved);</div><div class="line">    <span class="comment">//置null，让 GC 可以工作</span></div><div class="line">    elementData[--size] = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">return</span> oldValue;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 删除列表中首次出现的指定的元素，若列表不存在相应元素，则不做改变</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</div><div class="line">    <span class="comment">//若指定元素为 null，因其为空，没有 equals 方法，因此这两个地方做一个区分</span></div><div class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</div><div class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</div><div class="line">                fastRemove(index);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</div><div class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</div><div class="line">                fastRemove(index);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Private remove method that skips bounds checking and does not</span></div><div class="line"><span class="comment"> * return the value removed.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</div><div class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</div><div class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</div><div class="line">                         numMoved);</div><div class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 删除列表中所有的元素</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">    modCount++;</div><div class="line"></div><div class="line">    <span class="comment">// 置 null 以便让 GC 回收</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</div><div class="line">        elementData[i] = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    size = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 从列表中删除 fromIndex &lt;= pos &lt; toIndex 的元素</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">removeRange</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span> </span>&#123;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">int</span> numMoved = size - toIndex;</div><div class="line">    System.arraycopy(elementData, toIndex, elementData, fromIndex,</div><div class="line">                     numMoved);</div><div class="line"></div><div class="line">    <span class="comment">// clear to let GC do its work</span></div><div class="line">    <span class="keyword">int</span> newSize = size - (toIndex-fromIndex);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = newSize; i &lt; size; i++) &#123;</div><div class="line">        elementData[i] = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">    size = newSize;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="ArrayList的序列化"><a href="#ArrayList的序列化" class="headerlink" title="ArrayList的序列化"></a>ArrayList的序列化</h3><p>在 <a href="#主要字段">主要字段</a> 部分我们可以看到，<u>elementData</u> 是通过<code>transient</code>修饰的（<u>transient</u>具体用法可参看<a href="https://www.cnblogs.com/ZhaoxiCheung/p/Java-Serializable.html" target="_blank" rel="external">Java对象序列化</a>一文），通过<code>transient</code>声明，因此其无法通过序列化技术保存下来，但仔细阅读源码发现其内部实现了序列化和反序列化函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 保存 ArrayList 中实例的状态到序列中</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></div><div class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException</span>&#123;</div><div class="line">    <span class="comment">// Write out element count, and any hidden stuff</span></div><div class="line">    <span class="keyword">int</span> expectedModCount = modCount;</div><div class="line">    s.defaultWriteObject();</div><div class="line"></div><div class="line">    <span class="comment">// Write out size as capacity for behavioural compatibility with clone()</span></div><div class="line">    s.writeInt(size);</div><div class="line"></div><div class="line">    <span class="comment">// Write out all elements in the proper order.</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</div><div class="line">        s.writeObject(elementData[i]);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (modCount != expectedModCount) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 从序列中恢复 ArrayList 中实例的状态</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></div><div class="line"><span class="function">    <span class="keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;</div><div class="line">    elementData = EMPTY_ELEMENTDATA;</div><div class="line"></div><div class="line">    <span class="comment">// Read in size, and any hidden stuff</span></div><div class="line">    s.defaultReadObject();</div><div class="line"></div><div class="line">    <span class="comment">// Read in capacity</span></div><div class="line">    s.readInt(); <span class="comment">// ignored</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// be like clone(), allocate array based upon size not capacity</span></div><div class="line">        ensureCapacityInternal(size);</div><div class="line"></div><div class="line">        Object[] a = elementData;</div><div class="line">        <span class="comment">// Read in all elements in the proper order.</span></div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</div><div class="line">            a[i] = s.readObject();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>通过一个例子验证其序列化和反序列化过程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> test;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.*;</div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListDemo</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</div><div class="line">        List&lt;String&gt;list = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        list.add(<span class="string">"hello"</span>);</div><div class="line">        list.add(<span class="string">"world"</span>);</div><div class="line"></div><div class="line">        <span class="comment">//write Obj to File</span></div><div class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"file"</span>));</div><div class="line">        oos.writeObject(list);</div><div class="line">        oos.close();</div><div class="line"></div><div class="line">        <span class="comment">//read Obj from File</span></div><div class="line">        File file = <span class="keyword">new</span> File(<span class="string">"file"</span>);</div><div class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</div><div class="line">        List&lt;String&gt;newList = (List&lt;String&gt;) ois.readObject();</div><div class="line">        ois.close();</div><div class="line">        System.out.println(newList);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">[hello, world]</span></div><div class="line"><span class="comment"> */</span></div></pre></td></tr></table></figure></p>
<p>可以得出结论：ArrayList支持进行序列化操作，此时不禁会思考既然要将 ArrayList 的字段序列化（即将 elementData 序列化），那为什么又要用 transient 修饰 elementData 呢？实际上，ArrayList 通过动态数组的技术，当数组放满后，自动扩容，但是扩容后的容量往往都是大于或者等于 ArrayList 所存元素的个数。如果直接序列化 elementData 数组，那么就会序列化一大部分没有元素的数组，导致浪费空间，为了保证在序列化的时候不会将这么大部分没有元素的数组进行序列化，因此设置为 transient。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Write out all elements in the proper order.</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++)</div><div class="line">&#123;</div><div class="line">    s.writeObject(elementData[i]);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从源码中，可以观察到循环时是使用<code>i &lt; size</code>而不是<code>i&lt;elementData.length</code>，说明序列化时，只需实际存储的那些元素，而不是整个数组。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul>
<li><code>List&lt;Integer&gt;list = new ArrayList&lt;&gt;(10); out.println(list.get(1));</code>是否会抛出异常</li>
<li>ArrayList 支持序列化，为什么 <u>elementData</u> 要设置为<code>transient</code></li>
<li>对于空实例数组，为什么要区分<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>和<code>EMPTY_ELEMENTDATA</code></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下针对JDK 1.8版本中的&lt;strong&gt;ArrayList&lt;/strong&gt;进行分析。&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;code&gt;ArrayList&lt;/code&gt;基于&lt;code&gt;List&lt;/code&gt;接口实现的大小可变的数组。其实现了所有可选的&lt;code&gt;List&lt;/code&gt;操作，并且元素允许为任意类型，包括&lt;code&gt;null&lt;/code&gt;元素。除了实现&lt;code&gt;List&lt;/code&gt;接口，此类还提供了操作内部用于存储列表数组大小的方法（这个类除了没有实现同步外，功能基本与&lt;code&gt;Vector&lt;/code&gt;一致）。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java——源码分析" scheme="https://zhaoxizhang.github.io/tags/Java%E2%80%94%E2%80%94%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>链表专题——面试中常见的链表问题</title>
    <link href="https://zhaoxizhang.github.io/2018/10/26/A-list-of-common-problems-in-interviews-about-Linked%20list/"/>
    <id>https://zhaoxizhang.github.io/2018/10/26/A-list-of-common-problems-in-interviews-about-Linked list/</id>
    <published>2018-10-25T16:00:00.000Z</published>
    <updated>2018-11-06T16:39:45.537Z</updated>
    
    <content type="html"><![CDATA[<p><strong>声明：</strong>链表定义如下：<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Java:</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> val;</div><div class="line">    ListNode next = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    ListNode(<span class="keyword">int</span> val) &#123;</div><div class="line">        <span class="keyword">this</span>.val = val;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//C++:</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></div><div class="line">    <span class="keyword">int</span> val;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span>;</span></div><div class="line">    ListNode(<span class="keyword">int</span> x) :</div><div class="line">        val(x), next(<span class="literal">NULL</span>) &#123;</div><div class="line">    &#125;</div><div class="line">&#125;ListNode;</div></pre></td></tr></table></figure>
<p>&nbsp;</p>
<h3 id="从无头单链表中删除节点"><a href="#从无头单链表中删除节点" class="headerlink" title="从无头单链表中删除节点"></a>从无头单链表中删除节点</h3><p><strong>详情：</strong>给定一个没有头指针的单链表，一个指针指向此单链表中间的一个节点（不是第一个，也不是最后一个节点），请将该节点从单链表中删除。<br><strong>题解：</strong><br>解法一：由于单链表并没有给出头指针，因此我们无法通过遍历链表的方式找到该节点的前一个节点来改变其 next 指向去指向该节点的 next 节点。换一种思路，我们可以将该节点的元素值全部替换成其 next 节点，然后删除 next 节点，这样就相当于把该节点删除了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Java</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteRandomNode</span><span class="params">(ListNode currentNode)</span> </span>&#123;</div><div class="line">    ListNode nextNode = currentNode.next;</div><div class="line">    <span class="keyword">if</span> (nextNode != <span class="keyword">null</span>) &#123;</div><div class="line">        currentNode.val = nextNode.val;</div><div class="line">        currentNode.next = nextNode.next;</div><div class="line">    &#125;</div><div class="line">    nextNode = <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//C++</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteRandomNode</span><span class="params">(ListNode *current)</span></span>&#123;</div><div class="line">    ListNode *next = current-&gt;next;</div><div class="line">    <span class="keyword">if</span> (next != <span class="literal">NULL</span>)&#123;</div><div class="line">        current-&gt;val = next-&gt;val;</div><div class="line">        current-&gt;next = next-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">delete</span> next;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&nbsp;</p>
<h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><p><strong>详情：</strong>给定一个链表的头指针，要求只遍历一次，将单链表中的元素顺序反转过来。<br><strong>题解：</strong><br>解法一：题目较为简单，每次反转的时候记录下一个节点的指针<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Java</span></div><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">ReverseList</span><span class="params">(ListNode head)</span> </span>&#123;</div><div class="line">    ListNode pre = <span class="keyword">null</span>, next = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</div><div class="line">        next = head.next;</div><div class="line">        head.next = pre;</div><div class="line">        pre = head;</div><div class="line">        head = next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> pre;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//C++</span></div><div class="line"><span class="function">ListNode *<span class="title">ReverseList</span><span class="params">(ListNode *pHead)</span> </span>&#123;</div><div class="line">    ListNode *current = <span class="literal">NULL</span>, *prev = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">while</span> (pHead != <span class="literal">NULL</span>) &#123;</div><div class="line">        current = pHead;</div><div class="line">        pHead = pHead-&gt;next;</div><div class="line">        current-&gt;next = prev;</div><div class="line">        prev = current;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> current;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&nbsp;</p>
<h3 id="两个链表的第一个公共节点"><a href="#两个链表的第一个公共节点" class="headerlink" title="两个链表的第一个公共节点"></a>两个链表的第一个公共节点</h3><p><strong>详情：</strong>输入两个链表，找出它们的第一个公共节点<br><strong>题解：</strong><br>解法一：为了找到两个链表的公共节点，那么我们可以从尾往头遍历查找，但是只给了我们头节点，因此类似于栈的先进后出，因此我们可以用两个栈来保存节点，然后从栈中取出节点进行比较。<br>解法二：统计两个链表的长度 len1 和 len2，让较长的链表先走<code>abs(len1 - len2)</code>长度，之后二者同时继续往下遍历，查找第一个公共节点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//C++</span></div><div class="line"><span class="function">ListNode *<span class="title">FindFirstCommonNode</span><span class="params">( ListNode *pHead1, ListNode *pHead2)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> len1 = SizeLinkedList(pHead1);</div><div class="line">    <span class="keyword">int</span> len2 = SizeLinkedList(pHead2);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (len1 &gt; len2) &#123;</div><div class="line">        pHead1 = walker(pHead1, len1 - len2);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        pHead2 = walker(pHead2, len2 - len1);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (pHead1-&gt;val != pHead2-&gt;val) &#123;</div><div class="line">        pHead1 = pHead1-&gt;next;</div><div class="line">        pHead2 = pHead2-&gt;next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> pHead1;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">SizeLinkedList</span><span class="params">(ListNode *head)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)   <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> size = <span class="number">0</span>;</div><div class="line">    ListNode *current = head;</div><div class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</div><div class="line">        size++;</div><div class="line">        current = current-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> size;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">ListNode *<span class="title">walker</span><span class="params">(ListNode *head, <span class="keyword">int</span> cnt)</span> </span>&#123;</div><div class="line">    <span class="keyword">while</span> (cnt--) &#123;</div><div class="line">        head = head-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> head;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&nbsp;</p>
<h3 id="判断给定链表是否存在环"><a href="#判断给定链表是否存在环" class="headerlink" title="判断给定链表是否存在环"></a>判断给定链表是否存在环</h3><p><strong>详情：</strong>给定一个链表，判断这个链表是否存在环<br><strong>题解：</strong><br>解法一：<a href="https://www.cnblogs.com/ZhaoxiCheung/p/7355369.html" target="_blank" rel="external">Floyd判圈算法</a><br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//C++</span></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasRing</span><span class="params">(ListNode *pHead)</span></span>&#123;</div><div class="line">    <span class="keyword">bool</span> hasRing = <span class="literal">false</span>;</div><div class="line">    ListNode *fast = pHead, *slow = pHead;</div><div class="line">    <span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>)&#123;</div><div class="line">        fast = fast-&gt;next-&gt;next;</div><div class="line">        slow = slow-&gt;next;</div><div class="line">        <span class="keyword">if</span> (fast == slow)   hasRing = <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> hasRing;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&nbsp;</p>
<h3 id="链表中环的入口节点"><a href="#链表中环的入口节点" class="headerlink" title="链表中环的入口节点"></a>链表中环的入口节点</h3><p><strong>详情：</strong>给一个链表，若其中包含环，请找出该链表的环的入口结点，否则，输出null。<br><strong>题解：</strong><br>解法一：<a href="https://www.cnblogs.com/ZhaoxiCheung/p/7355369.html" target="_blank" rel="external">Floyd判圈算法</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Java</span></div><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode pHead)</span> </span>&#123;</div><div class="line">    ListNode fast = pHead, slow = pHead;</div><div class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</div><div class="line">        fast = fast.next.next;</div><div class="line">        slow = slow.next;</div><div class="line">        <span class="keyword">if</span> (fast == slow)   <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (fast == <span class="keyword">null</span> || fast.next == <span class="keyword">null</span>)  <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    fast = pHead;</div><div class="line">    <span class="keyword">while</span> (fast != slow) &#123;</div><div class="line">        fast = fast.next;</div><div class="line">        slow = slow.next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> fast;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//C++</span></div><div class="line"><span class="function">ListNode *<span class="title">EntryNodeOfLoop</span><span class="params">(ListNode *pHead)</span> </span>&#123;</div><div class="line">    ListNode *slow = pHead, *fast = pHead;</div><div class="line">    <span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next != <span class="literal">NULL</span>) &#123;</div><div class="line">        fast = fast-&gt;next-&gt;next;</div><div class="line">        slow = slow-&gt;next;</div><div class="line">        <span class="keyword">if</span> (fast == slow)   <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (fast == <span class="literal">NULL</span> || fast-&gt;next == <span class="literal">NULL</span>)   <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    fast = pHead;</div><div class="line">    <span class="keyword">while</span> (fast != slow) &#123;</div><div class="line">        fast = fast-&gt;next;</div><div class="line">        slow = slow-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> fast;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&nbsp;</p>
<h3 id="判断两个链表是否相交"><a href="#判断两个链表是否相交" class="headerlink" title="判断两个链表是否相交"></a>判断两个链表是否相交</h3><p><strong>详情：</strong>给定两个单链表的头指针，判断这两个链表是否相交。<br><strong>题解：</strong><br>解法一：若两个链表相交，则链表的最后一个节点一定是公共的，因此可以利用这个性质求解。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//C++</span></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isIntersect</span><span class="params">(ListNode *pHead1, ListNode *pHead2)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> (pHead1 == <span class="literal">NULL</span> || pHead2 == <span class="literal">NULL</span>)   <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    <span class="keyword">while</span> (pHead1-&gt;next != <span class="literal">NULL</span>)    pHead1 = pHead1-&gt;next;</div><div class="line">    <span class="keyword">while</span> (pHead2-&gt;next != <span class="literal">NULL</span>)    pHead2 = pHead2-&gt;next;</div><div class="line">    <span class="keyword">if</span> (pHead1 == pHead2)   <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>解法二：由于都是单项链表，也就是都没有环，那么我们可以把第一个链表链接到第二个链表后面，如果新的链表有环，证明了有公共节点。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//C++</span></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isIntersect</span><span class="params">(ListNode *pHead1, ListNode *pHead2)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> (pHead1 == <span class="literal">NULL</span> || pHead2 == <span class="literal">NULL</span>)   <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    pHead1-&gt;next = pHead2;</div><div class="line">    <span class="keyword">return</span> hasRing(pHead1);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&nbsp;</p>
<h3 id="判断两个链表是否相交变形"><a href="#判断两个链表是否相交变形" class="headerlink" title="判断两个链表是否相交变形"></a>判断两个链表是否相交<strong>变形</strong></h3><p><strong>详情：</strong>给定两个<strong>有环</strong>链表的头指针，判断这两个链表是否相交。<br><strong>题解：</strong><br>解法一：对于有环链表，如果相交，存在以下几种情况：<br><img src="https://img2018.cnblogs.com/blog/885804/201810/885804-20181026172408920-46021901.png" alt=""><br>因此，找到链表的入口节点，判断是否相等，对应情形一和二，对于三，我们可以固定一个节点，然后遍历链表来判断是否存在相交。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//C++</span></div><div class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isIntersect</span><span class="params">(ListNode *pHead1, ListNode *pHead2)</span></span>&#123;</div><div class="line">    <span class="keyword">if</span> (pHead1 == <span class="literal">NULL</span> || pHead2 == <span class="literal">NULL</span>)   <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    ListNode *entry1 = EntryNodeOfLoop(pHead1);</div><div class="line">    ListNode *entry2 = EntryNodeOfLoop(pHead2);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (entry1 == entry2)   <span class="keyword">return</span> <span class="literal">true</span>;</div><div class="line">    <span class="keyword">else</span>&#123;</div><div class="line">        ListNode *backup = entry2;</div><div class="line">        <span class="keyword">do</span></div><div class="line">        &#123;</div><div class="line">            entry2 = entry2-&gt;next;</div><div class="line">        &#125;<span class="keyword">while</span> (entry2 != entry1 &amp;&amp; entry2 != backup);</div><div class="line">        <span class="keyword">return</span> entry2 != backup;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&nbsp;</p>
<h3 id="合并两个排序的链表"><a href="#合并两个排序的链表" class="headerlink" title="合并两个排序的链表"></a>合并两个排序的链表</h3><p><strong>详情：</strong>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。<br><strong>题解：</strong><br>解法一：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//Java</span></div><div class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">Merge</span><span class="params">(ListNode list1, ListNode list2)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (list1 == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> list2;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (list2 == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> list1;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ListNode prev = <span class="keyword">null</span>;</div><div class="line">    ListNode root = list1.val &lt; list2.val ? list1 : list2;</div><div class="line">    <span class="keyword">while</span> (list1 != <span class="keyword">null</span> &amp;&amp; list2 != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (list1.val &lt; list2.val) &#123;</div><div class="line">            <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</div><div class="line">                prev = list1;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                prev.next = list1;</div><div class="line">                prev = list1;</div><div class="line">            &#125;</div><div class="line">            list1 = list1.next;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</div><div class="line">                prev = list2;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                prev.next = list2;</div><div class="line">                prev = list2;</div><div class="line">            &#125;</div><div class="line">            list2 = list2.next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (list1 != <span class="keyword">null</span>) &#123;</div><div class="line">        prev.next = list1;</div><div class="line">        prev = list1;</div><div class="line">        list1 = list1.next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (list2 != <span class="keyword">null</span>) &#123;</div><div class="line">        prev.next = list2;</div><div class="line">        prev = list2;</div><div class="line">        list2 = list2.next;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> root;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//C++</span></div><div class="line"><span class="function">ListNode *<span class="title">Merge</span><span class="params">(ListNode *pHead1, ListNode *pHead2)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (pHead1 == <span class="literal">NULL</span>) <span class="keyword">return</span> pHead2;</div><div class="line">    <span class="keyword">if</span> (pHead2 == <span class="literal">NULL</span>) <span class="keyword">return</span> pHead1;</div><div class="line">    ListNode *prev = <span class="literal">NULL</span>;</div><div class="line">    ListNode *root = pHead1-&gt;val &lt; pHead2-&gt;val ? pHead1 : pHead2;</div><div class="line">    <span class="keyword">while</span> (pHead1 != <span class="literal">NULL</span> &amp;&amp; pHead2 != <span class="literal">NULL</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (pHead1-&gt;val &lt; pHead2-&gt;val) &#123;</div><div class="line">            <span class="keyword">if</span> (prev == <span class="literal">NULL</span>) &#123;</div><div class="line">                prev = pHead1;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                prev-&gt;next = pHead1;</div><div class="line">                prev = pHead1;</div><div class="line">            &#125;</div><div class="line">            pHead1 = pHead1-&gt;next;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (prev == <span class="literal">NULL</span>) &#123;</div><div class="line">                prev = pHead2;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                prev-&gt;next = pHead2;</div><div class="line">                prev = pHead2;</div><div class="line">            &#125;</div><div class="line">            pHead2 = pHead2-&gt;next;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">while</span> (pHead1 != <span class="literal">NULL</span>) &#123;</div><div class="line">        prev-&gt;next = pHead1;</div><div class="line">        prev = pHead1;</div><div class="line">        pHead1 = pHead1-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">while</span> (pHead2 != <span class="literal">NULL</span>) &#123;</div><div class="line">        prev-&gt;next = pHead2;</div><div class="line">        prev = pHead2;</div><div class="line">        pHead2 = pHead2-&gt;next;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> root;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;声明：&lt;/strong&gt;链表定义如下：&lt;br&gt;
    
    </summary>
    
    
      <category term="Interviews" scheme="https://zhaoxizhang.github.io/tags/Interviews/"/>
    
      <category term="Linked list" scheme="https://zhaoxizhang.github.io/tags/Linked-list/"/>
    
  </entry>
  
  <entry>
    <title>Java——HashMap源码解析</title>
    <link href="https://zhaoxizhang.github.io/2018/10/21/Java-HashMap-Source-Analysis/"/>
    <id>https://zhaoxizhang.github.io/2018/10/21/Java-HashMap-Source-Analysis/</id>
    <published>2018-10-20T16:00:00.000Z</published>
    <updated>2018-11-06T16:39:37.680Z</updated>
    
    <content type="html"><![CDATA[<p>以下针对JDK 1.8版本中的<strong>HashMap</strong>进行分析。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;哈希表基于<code>Map</code>接口的实现。此实现提供了所有可选的映射操作，并且允许键为<code>null</code>，值也为<code>null</code>。HashMap 除了不支持同步操作以及支持<code>null</code>的键值外，其功能大致等同于 Hashtable。这个类不保证元素的顺序，并且也不保证随着时间的推移，元素的顺序不会改变。<br><a id="more"></a><br>&nbsp;&nbsp;&nbsp;&nbsp;假设散列函数使得元素在哈希桶中分布均匀，那么这个实现对于 <strong>put</strong> 和 <strong>get</strong> 等操作提供了常数时间的性能。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;对于一个 HashMap 的实例，有两个因子影响着其性能：<strong>初始容量</strong>和<strong>负载因子</strong>。容量就是哈希表中哈希桶的个数，初始容量就是哈希表被初次创建时的容量大小。负载因子是在进行自动扩容之前衡量哈希表存储键值对的一个指标。当哈希表中的键值对超过<code>capacity * loadfactor</code>时，就会进行 resize 的操作。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;作为一般规则，默认负载因子（0.75）在时间和空间成本之间提供了良好的折衷。负载因子越大，空间开销越小，但是查找的开销变大了。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;注意，迭代器的快速失败行为不能得到保证，一般来说，存在非同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出<code>ConcurrentModificationException</code>异常。因此，编写依赖于此异常的程序的做法是错误的，正确做法是：迭代器的快速失败行为应该仅用于检测程序错误。</p>
<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="主要字段"><a href="#主要字段" class="headerlink" title="主要字段"></a>主要字段</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 初始容量大小 —— 必须是2的幂次方</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 最大容量</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 默认负载因子</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 当链表长度超过这个值时转换为红黑树</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * The bin count threshold for untreeifying a (split) bin during a</span></div><div class="line"><span class="comment"> * resize operation. Should be less than TREEIFY_THRESHOLD, and at</span></div><div class="line"><span class="comment"> * most 6 to mesh with shrinkage detection under removal.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * The smallest table capacity for which bins may be treeified.</span></div><div class="line"><span class="comment"> * (Otherwise the table is resized if too many nodes in a bin.)</span></div><div class="line"><span class="comment"> * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts</span></div><div class="line"><span class="comment"> * between resizing and treeification thresholds.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * table 在第一次使用时进行初始化并在需要的时候重新调整自身大小。对于 table 的大小必须是2的幂次方。</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Holds cached entrySet(). Note that AbstractMap fields are used</span></div><div class="line"><span class="comment"> * for keySet() and values().</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 键值对的个数</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * HashMap 进行结构性调整的次数。结构性调整指的是增加或者删除键值对等操作，注意对于更新某个键的值不是结构特性调整。</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 所能容纳的 key-value 对的极限（表的大小 capacity * load factor），达到这个容量时进行扩容操作。</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">int</span> threshold;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 负载因子，默认值为 0.75</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</div></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;从上面我们可以得知，HashMap中指定的哈希桶数组<u>table.length</u>必须是2的幂次方，这与常规性的把哈希桶数组设计为素数不一样。指定为2的幂次方主要是在两方面做优化：</p>
<ul>
<li>扩容：扩容的时候，哈希桶扩大为当前的两倍，因此只需要进行左移操作</li>
<li>取模：由于哈希桶的个数为2的幂次，因此可以用<strong>&amp;</strong>操作来替代耗时的模运算， <code>n % table.length -&gt; n &amp; (table.length - 1)</code></li>
</ul>
<h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 哈希函数</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> h;</div><div class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;key 的哈希值通过它自身<strong>hashCode</strong>的高十六位与低十六位进行亦或得到。这么做得原因是因为，由于哈希表的大小固定为 2 的幂次方，那么某个 key 的 hashCode 值大于 table.length，其高位就不会参与到 hash 的计算（对于某个 key 其所在的桶的位置的计算为 <code>hash &amp; (table.length - 1)</code>）。因此通过<code>hashCode()</code>的高16位异或低16位实现的：<code>(h = key.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>，主要是从速度、功效、质量来考虑的，保证了高位 Bits 也能参与到 Hash 的计算。</p>
<h3 id="tableSizeFor函数"><a href="#tableSizeFor函数" class="headerlink" title="tableSizeFor函数"></a>tableSizeFor函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 返回大于等于capacity的最小2的整数次幂</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</div><div class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</div><div class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;根据注释可以知道，这个函数返回大于或等于<strong>cap</strong>的最小二的整数次幂的值。比如对于3，返回4；对于10，返回16。详解如下：<br>假设对于<strong>n</strong>（32位数）其二进制为 01xx…xx，<br>n &gt;&gt;&gt; 1，进行无符号右移一位， 001xx..xx，位或得 011xx..xx<br>n &gt;&gt;&gt; 2，进行无符号右移两位， 00011xx..xx，位或得 01111xx..xx<br>依此类推，无符号右移四位再进行位或将得到8个1，无符号右移八位再进行位或将得到16个1，无符号右移十六位再进行位或将得到32个1。根据这个我们可以知道进行这么多次无符号右移及位或操作，那么可让数<strong>n</strong>的二进制位最高位为1的后面的二进制位全部变成1。此时进行 +1 操作，即可得到最小二的整数次幂的值。（《高效程序的奥秘》第3章——2的幂界方 有对此进行进一步讨论，可自行查看）<br>回到上面的程序，之所以在开头先进行一次 -1 操作，是为了防止传入的<strong>cap</strong>本身就是二的幂次方，此时得到的就是下一个二的幂次方了，比如传入4，那么在不进行 -1 的情况下，将得到8。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 传入指定的初始容量和负载因子</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</div><div class="line">                                           initialCapacity);</div><div class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</div><div class="line">        initialCapacity = MAXIMUM_CAPACITY;</div><div class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</div><div class="line">                                           loadFactor);</div><div class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</div><div class="line">    <span class="comment">//返回2的幂次方</span></div><div class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;对于上面的构造器，我们需要注意的是<code>this.threshold = tableSizeFor(initialCapacity);</code>这边的 threshold 为 2的幂次方，而不是<code>capacity * load factor</code>，当然此处并非是错误，因为此时 table 并没有真正的被初始化，初始化动作被延迟到了<code>putVal()</code>当中，所以 threshold 会被重新计算。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 根据指定的容量以及默认负载因子（0.75）初始化一个空的 HashMap 实例</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * 如果 initCapacity是负数，那么将抛出 IllegalArgumentException</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 根据默认的容量和负载因子初始化一个空的 HashMap 实例</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Constructs a new &lt;tt&gt;HashMap&lt;/tt&gt; with the same mappings as the</span></div><div class="line"><span class="comment"> * specified &lt;tt&gt;Map&lt;/tt&gt;.  The &lt;tt&gt;HashMap&lt;/tt&gt; is created with</span></div><div class="line"><span class="comment"> * default load factor (0.75) and an initial capacity sufficient to</span></div><div class="line"><span class="comment"> * hold the mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span>   m the map whose mappings are to be placed in this map</span></div><div class="line"><span class="comment"> * <span class="doctag">@throws</span>  NullPointerException if the specified map is null</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</div><div class="line">    putMapEntries(m, <span class="keyword">false</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 返回指定 key 所对应的 value 值，当不存在指定的 key 时，返回 null。</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * 当返回 null 的时候并不表明哈希表中不存在这种关系的映射，有可能对于指定的 key，其对应的值就是 null。</span></div><div class="line"><span class="comment"> * 因此可以通过 containsKey 来区分这两种情况。</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt; e;</div><div class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 1.首先通过 key 的哈希值找到其所在的哈希桶</span></div><div class="line"><span class="comment"> * 2.对于 key 所在的哈希桶只有一个元素，此时就是 key 对应的节点，</span></div><div class="line"><span class="comment"> * 3.对于 key 所在的哈希桶超过一个节点，此时分两种情况：</span></div><div class="line"><span class="comment"> *     如果这是一个 TreeNode，表明通过红黑树存储，在红黑树中查找</span></div><div class="line"><span class="comment"> *     如果不是一个 TreeNode，表明通过链表存储（链地址法），在链表中查找</span></div><div class="line"><span class="comment"> * 4.查找不到相应的 key，返回 null</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</div><div class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></div><div class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            <span class="keyword">return</span> first;</div><div class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</div><div class="line">            <span class="keyword">do</span> &#123;</div><div class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                    <span class="keyword">return</span> e;</div><div class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 在映射中，将指定的键与指定的值相关联。如果映射关系之前已经有指定的键，那么旧值就会被替换</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * * <span class="doctag">@param</span> onlyIfAbsent if true, don't change existing value</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * 1.判断哈希表 table 是否为空，是的话进行扩容操作</span></div><div class="line"><span class="comment"> * 2.根据键 key 计算得到的 哈希桶数组索引，如果 table[i] 为空，那么直接新建节点</span></div><div class="line"><span class="comment"> * 3.判断 table[i] 的首个元素是否等于 key，如果是的话就更新旧的 value 值</span></div><div class="line"><span class="comment"> * 4.判断 table[i] 是否为 TreeNode，是的话即为红黑树，直接在树中进行插入</span></div><div class="line"><span class="comment"> * 5.遍历 table[i]，遍历过程发现 key 已经存在，更新旧的 value 值，否则进行插入操作，插入后发现链表长度大于8，则将链表转换为红黑树</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></div><div class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</div><div class="line">    <span class="comment">//哈希表 table 为空，进行扩容操作</span></div><div class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</div><div class="line">        n = (tab = resize()).length;</div><div class="line">    <span class="comment">// tab[i] 为空，直接新建节点</span></div><div class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</div><div class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        Node&lt;K,V&gt; e; K k;</div><div class="line">        <span class="comment">//tab[i] 首个元素即为 key，更新旧值</span></div><div class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</div><div class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            e = p;</div><div class="line">        <span class="comment">//当前节点为 TreeNode，在红黑树中进行插入</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</div><div class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">//遍历 tab[i]，key 已经存在，更新旧的 value 值，否则进心插入操作，插入后链表长度大于8，将链表转换为红黑树</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</div><div class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</div><div class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</div><div class="line">                    <span class="comment">//链表长度大于8</span></div><div class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></div><div class="line">                        treeifyBin(tab, hash);</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">// key 已经存在</span></div><div class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                p = e;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//key 已经存在，更新旧值</span></div><div class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></div><div class="line">            V oldValue = e.value;</div><div class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</div><div class="line">                e.value = value;</div><div class="line">            afterNodeAccess(e);</div><div class="line">            <span class="keyword">return</span> oldValue;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//HashMap插入元素表明进行了结构性调整</span></div><div class="line">    ++modCount;</div><div class="line">    <span class="comment">//实际键值对数量超过 threshold，进行扩容操作</span></div><div class="line">    <span class="keyword">if</span> (++size &gt; threshold)</div><div class="line">        resize();</div><div class="line">    afterNodeInsertion(evict);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 初始化或者对哈希表进行扩容操作。如果当前哈希表为空，则根据字段阈值中的初始容量进行分配。</span></div><div class="line"><span class="comment"> * 否则，因为我们扩容两倍，那么对于桶中的元素要么在原位置，要么在原位置再移动2次幂的位置。</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</div><div class="line">    Node&lt;K,V&gt;[] oldTab = table;</div><div class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</div><div class="line">    <span class="keyword">int</span> oldThr = threshold;</div><div class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">//超过最大容量，不再进行扩容</span></div><div class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</div><div class="line">            threshold = Integer.MAX_VALUE;</div><div class="line">            <span class="keyword">return</span> oldTab;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//容量没有超过最大值，容量变为原来两倍</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</div><div class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</div><div class="line">            <span class="comment">//阈值变为原来两倍</span></div><div class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></div><div class="line">        <span class="comment">//调用了HashMap的带参构造器，初始容量用threshold替换，</span></div><div class="line">        <span class="comment">//在带参构造器中，threshold的值为 tableSizeFor() 的返回值，也就是2的幂次方，而不是 capacity * load factor</span></div><div class="line">        newCap = oldThr;</div><div class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></div><div class="line">        <span class="comment">//初次初始化，容量和阈值使用默认值</span></div><div class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</div><div class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">//计算新的阈值</span></div><div class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</div><div class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</div><div class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</div><div class="line">    &#125;</div><div class="line">    threshold = newThr;</div><div class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</div><div class="line">    <span class="comment">//以下为扩容过程的重点</span></div><div class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</div><div class="line">    table = newTab;</div><div class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</div><div class="line">            Node&lt;K,V&gt; e;</div><div class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</div><div class="line">                <span class="comment">//将原哈希桶置空，以便GC</span></div><div class="line">                oldTab[j] = <span class="keyword">null</span>;</div><div class="line">                <span class="comment">//当前节点不是以链表形式存在，直接计算其应放置的新位置</span></div><div class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</div><div class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</div><div class="line">                <span class="comment">//当前节点是TreeNode</span></div><div class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</div><div class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></div><div class="line">                    <span class="comment">//节点以链表形式存储</span></div><div class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</div><div class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</div><div class="line">                    Node&lt;K,V&gt; next;</div><div class="line">                    <span class="keyword">do</span> &#123;</div><div class="line">                        next = e.next;</div><div class="line">                        <span class="comment">//原索引</span></div><div class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</div><div class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</div><div class="line">                                loHead = e;</div><div class="line">                            <span class="keyword">else</span></div><div class="line">                                loTail.next = e;</div><div class="line">                            loTail = e;</div><div class="line">                        &#125;</div><div class="line">                        <span class="comment">//原索引 + oldCap</span></div><div class="line">                        <span class="keyword">else</span> &#123;</div><div class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</div><div class="line">                                hiHead = e;</div><div class="line">                            <span class="keyword">else</span></div><div class="line">                                hiTail.next = e;</div><div class="line">                            hiTail = e;</div><div class="line">                        &#125;</div><div class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</div><div class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</div><div class="line">                        loTail.next = <span class="keyword">null</span>;</div><div class="line">                        newTab[j] = loHead;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</div><div class="line">                        hiTail.next = <span class="keyword">null</span>;</div><div class="line">                        newTab[j + oldCap] = hiHead;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> newTab;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;因为哈希表使用2次幂的拓展（指长度拓展为原来的2倍），所以在扩容的时候，元素的位置要么在原位置，要么在原位置再移动2次幂的位置。为什么是这么一个规律呢？我们假设 n 为 table 的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。<br><img src="https://img2018.cnblogs.com/blog/885804/201810/885804-20181019224530421-1332118445.png" alt=""><br>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：<br><img src="https://img2018.cnblogs.com/blog/885804/201810/885804-20181019224541190-1566201160.png" alt=""><br>因此，我们在扩容的时候，只需要看看原来的hash值新增的那个 bit 是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图：<br><img src="https://img2018.cnblogs.com/blog/885804/201810/885804-20181019224623146-495310474.png" alt=""></p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 删除指定的 key 的映射关系</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt; e;</div><div class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</div><div class="line">        <span class="keyword">null</span> : e.value;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**Java</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * 1.根据 key 的哈希值在哈希桶中查找是否存在这个包含有这个 key 的节点</span></div><div class="line"><span class="comment"> *      链表头节点是要查找的节点</span></div><div class="line"><span class="comment"> *      节点是TreeNode，在红黑树中查找</span></div><div class="line"><span class="comment"> *      在链表中进行查找</span></div><div class="line"><span class="comment"> * 2.如果查找到对应的节点，进行删除操作</span></div><div class="line"><span class="comment"> *      从红黑树中删除</span></div><div class="line"><span class="comment"> *      将链表头节点删除</span></div><div class="line"><span class="comment"> *      在链表中删除</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> hash key 的 hash 值</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> key 指定的 key</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> value 当 matchhValue 为真时，则要匹配这个 value</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> matchValue 为真并且与 value 相等时进行删除</span></div><div class="line"><span class="comment"> * <span class="doctag">@param</span> movable if false do not move other nodes while removing</span></div><div class="line"><span class="comment"> * <span class="doctag">@return</span> the node, or null if none</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></div><div class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</div><div class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</div><div class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</div><div class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</div><div class="line">        <span class="comment">//链表头即为要删除的节点</span></div><div class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</div><div class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</div><div class="line">            node = p;</div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">//节点为TreeNode，在红黑树中查找是否存在指定的key</span></div><div class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</div><div class="line">            <span class="keyword">else</span> &#123;</div><div class="line">                <span class="comment">//在链表中查找是否存在指定的key</span></div><div class="line">                <span class="keyword">do</span> &#123;</div><div class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</div><div class="line">                        ((k = e.key) == key ||</div><div class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</div><div class="line">                        node = e;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                    p = e;</div><div class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</div><div class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</div><div class="line">            <span class="comment">//从红黑树中删除</span></div><div class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</div><div class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</div><div class="line">            <span class="comment">//链表头删除</span></div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</div><div class="line">                tab[index] = node.next;</div><div class="line">            <span class="comment">//链表中的元素删除</span></div><div class="line">            <span class="keyword">else</span></div><div class="line">                p.next = node.next;</div><div class="line">            <span class="comment">//进行结构特性调整</span></div><div class="line">            ++modCount;</div><div class="line">            --size;</div><div class="line">            afterNodeRemoval(node);</div><div class="line">            <span class="keyword">return</span> node;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 删除所有的映射关系</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</div><div class="line">    Node&lt;K,V&gt;[] tab;</div><div class="line">    modCount++;</div><div class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</div><div class="line">        size = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i)</div><div class="line">            <span class="comment">//置 null 以便 GC</span></div><div class="line">            tab[i] = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ul>
<li>对于<code>new HashMap(18)</code>，那么哈希桶数组的大小是多少</li>
<li>HashMap 要求哈希桶数组的长度是2的幂次方，这么设计的目的是为什么</li>
<li>HashMap 何时对哈希桶数组开辟内存</li>
<li>哈希函数是如何设计的，这么设计的意图是什么</li>
<li>HashMap 扩容的过程，扩容时候对 rehash 进行了什么优化</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://tech.meituan.com/java_hashmap.html" target="_blank" rel="external">Java 8系列之重新认识HashMap</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以下针对JDK 1.8版本中的&lt;strong&gt;HashMap&lt;/strong&gt;进行分析。&lt;/p&gt;
&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;哈希表基于&lt;code&gt;Map&lt;/code&gt;接口的实现。此实现提供了所有可选的映射操作，并且允许键为&lt;code&gt;null&lt;/code&gt;，值也为&lt;code&gt;null&lt;/code&gt;。HashMap 除了不支持同步操作以及支持&lt;code&gt;null&lt;/code&gt;的键值外，其功能大致等同于 Hashtable。这个类不保证元素的顺序，并且也不保证随着时间的推移，元素的顺序不会改变。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java——源码分析" scheme="https://zhaoxizhang.github.io/tags/Java%E2%80%94%E2%80%94%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>加载动态链接库——dlopen dlsym dlclose</title>
    <link href="https://zhaoxizhang.github.io/2018/09/29/The-use-of-dlopen%20dlmopen%20dlclose-in-C/"/>
    <id>https://zhaoxizhang.github.io/2018/09/29/The-use-of-dlopen dlmopen dlclose-in-C/</id>
    <published>2018-09-28T16:00:00.000Z</published>
    <updated>2018-11-06T15:06:50.782Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DLOPEN-nbsp-DLMOPEN-nbsp-DLCLOSE"><a href="#DLOPEN-nbsp-DLMOPEN-nbsp-DLCLOSE" class="headerlink" title="DLOPEN&nbsp;DLMOPEN&nbsp;DLCLOSE"></a>DLOPEN&nbsp;DLMOPEN&nbsp;DLCLOSE</h2><h3 id="NAME"><a href="#NAME" class="headerlink" title="NAME"></a>NAME</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>dlclose, dlopen, dlmopen</strong> - 打开／关闭共享对象<br><a id="more"></a></p>
<h3 id="SYNOPSIS"><a href="#SYNOPSIS" class="headerlink" title="SYNOPSIS"></a>SYNOPSIS</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">dlopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">int</span> flags)</span></span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">dlclose</span><span class="params">(<span class="keyword">void</span> *handle)</span></span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">dlmopen</span> <span class="params">(Lmid_t lmid, <span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">int</span> flags)</span></span>;</div></pre></td></tr></table></figure>
<h3 id="DESCRIPTION"><a href="#DESCRIPTION" class="headerlink" title="DESCRIPTION"></a>DESCRIPTION</h3><h4 id="dlopen"><a href="#dlopen" class="headerlink" title="dlopen()"></a>dlopen()</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;这个函数加载由以null结尾的字符串文件名命名的动态共享对象（共享库）文件，并为加载的对象返回不透明的“句柄”。此句柄与 dlopen API 中的其他函数一起使用，例如<code>dlsym()</code>，<code>dladdr()</code>，<code>dlinfo()</code>和<code>dlclose()</code>。</p>
<p>如果 <u>filename</u> 为 NULL，则返回的句柄用于主程序。如果 <u>filename</u> 包含斜杠（“/”），则它被解释为（相对或绝对）路径名。否则，动态链接器将按如下方式搜索对象（有关详细信息，请参阅<code>ld.so(8)</code>）：</p>
<ul>
<li>（仅限ELF）如果调用程序的可执行文件包含 DT_RPATH 标记，并且不包含 DT_RUNPATH 标记，则会搜索 DT_RPATH 标记中列出的目录。</li>
<li>如果在程序启动时，环境变量 LD_LIBRARY_PATH 被定义为包含以冒号分隔的目录列表，则会搜索这些目录。 （作为安全措施，set-user-ID 和 set-group-ID程序将忽略此变量。）</li>
<li>（仅限ELF）如果调用程序的可执行文件包含　DT_RUNPATH　标记，则搜索该标记中列出的目录。</li>
<li>检查缓存文件/etc/ld.so.cache（由ldconfig（8）维护）以查看它是否包含filename的条目。</li>
<li>搜索目录 /lib和 /usr/lib（按此顺序）。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;如果 <u>filename</u> 指定的对象依赖于其他共享对象，则动态链接器也会使用相同的规则自动加载这些对象。 （如果这些对象依次具有依赖性，则此过程可以递归地发生）</p>
<p><u>flags</u> 参数必须包括以下两个值中的一个：</p>
<ul>
<li>RTLD_LAZY<br>执行延迟绑定。仅在执行引用它们的代码时解析符号。如果从未引用该符号，则永远不会解析它（只对函数引用执行延迟绑定;在加载共享对象时，对变量的引用总是立即绑定）。自 glibc 2.1.1，此标志被<strong>LD_BIND_NOW</strong>环境变量的效果覆盖。</li>
<li>RTLD_NOW<br>如果指定了此值，或者环境变量<strong>LD_BIND_NOW</strong>设置为非空字符串，则在<code>dlopen()</code>返回之前，将解析共享对象中的所有未定义符号。如果无法执行此操作，则会返回错误。</li>
</ul>
<p><u>flags</u> 也可以通过以下零或多个值进行或运算设置：</p>
<ul>
<li>RTLD_GLOBAL<br>此共享对象定义的符号将可用于后续加载的共享对象的符号解析。</li>
<li>RTLD_LOCAL<br>这与<strong>RTLD_GLOBAL</strong>相反，如果未指定任何标志，则为默认值。此共享对象中定义的符号不可用于解析后续加载的共享对象中的引用。</li>
<li>RTLD_NODELETE (since glibc 2.2)<br>在<code>dlclose()</code>期间不要卸载共享对象。因此，如果稍后使用<code>dlopen()</code>重新加载对象，则不会重新初始化对象的静态变量。</li>
<li>RTLD_NOLOAD (since glibc 2.2)<br>不要加载共享对象。这可用于测试对象是否已经驻留（如果不是，则<code>dlopen()</code>返回 NULL，如果是驻留则返回对象的句柄）。此标志还可用于提升已加载的共享对象上的标志。例如，以前使用<strong>RTLD_LOCAL</strong>加载的共享对象可以使用<strong>RTLD_NOLOAD | RTLD_GLOBAL</strong>重新打开。</li>
<li>RTLD_DEEPBIND (since glibc 2.3.4)<br>将符号的查找范围放在此共享对象的全局范围之前。这意味着自包含对象将优先使用自己的符号，而不是全局符号，这些符号包含在已加载的对象中。</li>
</ul>
<h4 id="dlmopen"><a href="#dlmopen" class="headerlink" title="dlmopen()"></a>dlmopen()</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;这个函数除了以下几点与<code>dlopen()</code>有所不同外，都执行同样的任务。<br>&nbsp;&nbsp;&nbsp;&nbsp;<code>dlmopen()</code>与<code>dlopen()</code>的主要不同之处主要在于它接受另一个参数 <u>lmid</u>，它指定应该被加载的共享对象的链接映射列表（也称为命名空间）。对于命名空间，<u>Lmid_t</u> 是个不透明的句柄。<br><u>lmid</u> 参数要么是已经存在的命名空间的ID（这个命名空间可以通过<code>dlinfo RTLD_DI_LMID</code>请求获得）或者是以下几个特殊值中的其中一个：</p>
<ul>
<li>LM_ID_BASE<br>在初始命名空间中加载共享对象（即应用程序的命名空间）。</li>
<li>LM_ID_NEWLM<br>创建新的命名空间并在该命名空间中加载共享对象。该对象必须已正确链接到引用               所有其他需要的共享对象，因为新的命名空间最初为空。</li>
</ul>
<p>如果 <u>filename</u> 是 NULL，那么 <u>lmid</u> 的值只能是<strong>LM_ID_BASE</strong>。</p>
<h4 id="dlclose"><a href="#dlclose" class="headerlink" title="dlclose()"></a>dlclose()</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;<code>dlclose()</code>减少指定句柄 <u>handle</u> 引用的动态加载共享对象的引用计数。如果引用计数减少为０，那么这个动态加载共享对象将被真正卸载。所有在<code>dlopen()</code>被调用的时候自动加载的共享对象将以相同的方式递归关闭。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<code>dlclose()</code>成功返回并不保证与句柄相关的符号将从调用方的地址空间中删除。除了显式通过<code>dlopen()</code>调用产生的引用之外，一些共享对象作为依赖项可能已被隐式加载（和引用计数）。只有当所有引用都已被释放才可以从地址空间中删除共享对象。</p>
<h3 id="RETURN-VALUE"><a href="#RETURN-VALUE" class="headerlink" title="RETURN VALUE"></a>RETURN VALUE</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;执行成功时，<code>dlopen()</code>和<code>dlmopen()</code>返回一个非空句柄。<br>&nbsp;&nbsp;&nbsp;&nbsp;执行失败时（文件找不到、不可读、错误的格式或者在加载的时候出现错误），<code>dlopen()</code>和<code>dlmopen()</code>返回 NULL。<br>&nbsp;&nbsp;&nbsp;&nbsp;对于<code>dlclose()</code>成功执行，将返回０值，失败时，返回一个非０值。</p>
<p>以上这些函数产生的错误，其错误信息都可以通过<code>dlerror()</code>获知。</p>
<h3 id="NOTES"><a href="#NOTES" class="headerlink" title="NOTES"></a>NOTES</h3><h4 id="dlmopen-与-命名空间"><a href="#dlmopen-与-命名空间" class="headerlink" title="dlmopen() 与 命名空间"></a>dlmopen() 与 命名空间</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;链接映射列表定义了通过动态链接器解析的符号的孤立命名空间。在命名空间内，被依赖的共享对象根据通常的规则被隐式加载，符号引用同样以通常的规则被解析。但是这种方案受限于已经被（显式和隐式）加载进命名空间的对象的定义。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<code>dlmopen()</code>函数允许对象隔离加载——在新的命名空间中加载共享对象而不暴露其余的应用于新对象提供的符号。注意使用<strong>RTLD_LOCAL</strong>标志不足以达到此目的，因为它防止一个共享对象的符号对<strong>任何其他</strong>共享对象可用。在某些情况下，我们可能想使得由一些动态加载共享对象提供的符号对于其他共享对象可用，而不将这些符号暴露给整个应用。这可以通过使用单独的命名空间和<strong>RTLD_GLOBAL</strong>标志来实现。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<code>dlmopen()</code>函数可以提供比<strong>RTLD_LOCAL</strong>标志更好的隔离效果。特别是，当共享对象是通过<strong>RTLD_LOCAL</strong>标志加载的，并且其依赖的共享对象是通过<strong>RTLD_GLOBAL</strong>加载的，那么有可能升级为<strong>RTLD_GLOBAL</strong>。因此，明确控制了所有共享对象的依赖的这种情况外，<strong>RTLD_LOCAL</strong>是不足以隔离加载的共享对象，。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<code>dlmopen()</code>函数的一种用法是多次加载同样的对象。不使用<code>dlmopen()</code>函数来实现这个功能的话，需要创建共享对象的一个副本。而如果使用<code>dlmopen()</code>函数来实现的话，可以通过将相同的共享对象文件加载到不同的命名空间来实现。<br>       glibc实现最多支持16个命名空间。</p>
<h4 id="初始化和终结功能"><a href="#初始化和终结功能" class="headerlink" title="初始化和终结功能"></a>初始化和终结功能</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;共享对象可以使用<strong><strong>attribute </strong>((constructor))</strong>和<strong><strong>attribute </strong>((destructor))</strong>函数属性。构造函数在<code>dlopen()</code>返回之前执行，而析构函数在<code>dlclose()</code>返回之前执行。共享对象可以导出多个构造函数和析构函数并且优先顺序可以和每个函数相关联来决定它们的执行顺序。</p>
<h2 id="DLSYM"><a href="#DLSYM" class="headerlink" title="DLSYM"></a>DLSYM</h2><h3 id="NAME-1"><a href="#NAME-1" class="headerlink" title="NAME"></a>NAME</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>dlsym, dlvsym</strong> - 获取共享对象或可执行文件中符号的地址</p>
<h3 id="SYNOPSIS-1"><a href="#SYNOPSIS-1" class="headerlink" title="SYNOPSIS"></a>SYNOPSIS</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">dlsym</span><span class="params">(<span class="keyword">void</span> *handle, <span class="keyword">const</span> <span class="keyword">char</span> *symbol)</span></span>;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">dlvsym</span><span class="params">(<span class="keyword">void</span> *handle, <span class="keyword">char</span> *symbol, <span class="keyword">char</span> *version)</span></span>;</div></pre></td></tr></table></figure>
<h3 id="DESCRIPTION-1"><a href="#DESCRIPTION-1" class="headerlink" title="DESCRIPTION"></a>DESCRIPTION</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;<code>dlsym()</code>接受由<code>dlopen()</code>返回的动态加载的共享对象的“句柄”，并返回该符号加载到内存中的地址。如果未找到符号，则在加载该对象时，在指定对象或<code>dlopen()</code>自动加载的任何共享对象中，<code>dlsym()</code>将返回NULL。（<code>dlsym()</code>通过这些共享对象的依赖关系树进行宽度优先搜索。）<br>&nbsp;&nbsp;&nbsp;&nbsp;因为符号本身可能是 NULL（所以<code>dlsym()</code>返回 NULL 并不意味着错误），因此判断是否错误的正确做法是调用<code>dlerror()</code>清除任何旧的错误条件，然后调用<code>dlsym()</code>，并且再次调用<code>dlerror()</code>，保存其返回值，判断这个保存的值是否是 NULL。<br>&nbsp;&nbsp;&nbsp;&nbsp;可以在句柄中指定两个特殊的伪句柄：</p>
<ul>
<li>RTLD_DEFAULT<br>使用默认共享对象搜索顺序查找所需符号的第一个匹配项。搜索将包括可执行文件中的全局符号及其依赖项，以及使用<strong>RTLD_GLOBAL</strong> 标志动态加载的共享对象中的符号。</li>
<li>RTLD_NEXT<br>在当前对象之后的搜索顺序中查找下一个所需符号。这允许人们在另一个共享对象中提供一个函数的包装器，因此，例如，预加载的共享对象中的函数定义（参见ld.so（8）中的<strong>LD_PRELOAD</strong>）可以找到并调用在另一个共享对象中提供的“真实”函数（或者就此而言，在存在多个预加载层的情况下，函数的“下一个”定义）。</li>
</ul>
<p>&nbsp;&nbsp;&nbsp;&nbsp;<code>dlvsym()</code>除了比<code>dlsym()</code>多提供了一个额外的参数外，其余与<code>dlsym()</code>相同。</p>
<h3 id="RETURN-VALUE-1"><a href="#RETURN-VALUE-1" class="headerlink" title="RETURN VALUE"></a>RETURN VALUE</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;执行成功，这些函数将会返回　<u>symbol</u> 关联的地址。执行失败，它们将返回 NULL。错误的原因可以通过<code>dlerror()</code>进行诊断。</p>
<h2 id="EXAMPLE"><a href="#EXAMPLE" class="headerlink" title="EXAMPLE"></a>EXAMPLE</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;gnu/lib-names.h&gt;  /* Defines LIBM_SO (which will be a string such as "libm.so.6") */</span></span></div><div class="line"><span class="keyword">int</span></div><div class="line">main(<span class="keyword">void</span>)</div><div class="line">&#123;</div><div class="line">  <span class="keyword">void</span> *handle;</div><div class="line">  <span class="keyword">double</span> (*cosine)(<span class="keyword">double</span>);</div><div class="line">  <span class="keyword">char</span> *error;</div><div class="line"></div><div class="line">  handle = dlopen(LIBM_SO, RTLD_LAZY);</div><div class="line">  <span class="keyword">if</span> (!handle) &#123;</div><div class="line">     <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, dlerror());</div><div class="line">     <span class="built_in">exit</span>(EXIT_FAILURE);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  dlerror();    <span class="comment">/* Clear any existing error */</span></div><div class="line"></div><div class="line">  cosine = (<span class="keyword">double</span> (*)(<span class="keyword">double</span>)) dlsym(handle, <span class="string">"cos"</span>);</div><div class="line"></div><div class="line">  <span class="comment">/* According to the ISO C standard, casting between function</span></div><div class="line"><span class="comment">    pointers and 'void *', as done above, produces undefined results.</span></div><div class="line"><span class="comment">    POSIX.1-2003 and POSIX.1-2008 accepted this state of affairs and</span></div><div class="line"><span class="comment">    proposed the following workaround:</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">        *(void **) (&amp;cosine) = dlsym(handle, "cos");</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">    This (clumsy) cast conforms with the ISO C standard and will</span></div><div class="line"><span class="comment">    avoid any compiler warnings.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">    The 2013 Technical Corrigendum to POSIX.1-2008 (a.k.a.</span></div><div class="line"><span class="comment">    POSIX.1-2013) improved matters by requiring that conforming</span></div><div class="line"><span class="comment">    implementations support casting 'void *' to a function pointer.</span></div><div class="line"><span class="comment">    Nevertheless, some compilers (e.g., gcc with the '-pedantic'</span></div><div class="line"><span class="comment">    option) may complain about the cast used in this program. */</span></div><div class="line"></div><div class="line">  error = dlerror();</div><div class="line">  <span class="keyword">if</span> (error != <span class="literal">NULL</span>) &#123;</div><div class="line">     <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%s\n"</span>, error);</div><div class="line">     <span class="built_in">exit</span>(EXIT_FAILURE);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="built_in">printf</span>(<span class="string">"%f\n"</span>, (*cosine)(<span class="number">2.0</span>));</div><div class="line">  dlclose(handle);</div><div class="line">  <span class="built_in">exit</span>(EXIT_SUCCESS);</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;DLOPEN-nbsp-DLMOPEN-nbsp-DLCLOSE&quot;&gt;&lt;a href=&quot;#DLOPEN-nbsp-DLMOPEN-nbsp-DLCLOSE&quot; class=&quot;headerlink&quot; title=&quot;DLOPEN&amp;nbsp;DLMOPEN&amp;nbsp;DLCLOSE&quot;&gt;&lt;/a&gt;DLOPEN&amp;nbsp;DLMOPEN&amp;nbsp;DLCLOSE&lt;/h2&gt;&lt;h3 id=&quot;NAME&quot;&gt;&lt;a href=&quot;#NAME&quot; class=&quot;headerlink&quot; title=&quot;NAME&quot;&gt;&lt;/a&gt;NAME&lt;/h3&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;strong&gt;dlclose, dlopen, dlmopen&lt;/strong&gt; - 打开／关闭共享对象&lt;br&gt;
    
    </summary>
    
    
      <category term="C" scheme="https://zhaoxizhang.github.io/tags/C/"/>
    
      <category term="函数详解" scheme="https://zhaoxizhang.github.io/tags/%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式——建造者模式（创建型模式）</title>
    <link href="https://zhaoxizhang.github.io/2018/06/17/Java-Design-Patterns-Builder/"/>
    <id>https://zhaoxizhang.github.io/2018/06/17/Java-Design-Patterns-Builder/</id>
    <published>2018-06-16T16:00:00.000Z</published>
    <updated>2018-11-06T14:58:19.052Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&nbsp;&nbsp;建造者模式也称为生成器模式，是一种对象创建型模式，它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。<br><a id="more"></a><br>&nbsp;&nbsp;建造者模式意在为重叠构造器这种反模式(telescoping constructor anti-pattern)找到一种解决方案，对于重叠构造器反模式，我们经常能看到类似于下列的构造器形式（下述例子来源于《Effective Java》）：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">NutritionFacts</span><span class="params">(<span class="keyword">int</span> servingSize, <span class="keyword">int</span> servings)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(servingSize, servings, <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">NutritionFacts</span><span class="params">(<span class="keyword">int</span> servingSize, <span class="keyword">int</span> servings, <span class="keyword">int</span> calories)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(servingSize, servings, calories, <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">NutritionFacts</span><span class="params">(<span class="keyword">int</span> servingSize, <span class="keyword">int</span> servings, <span class="keyword">int</span> calories, <span class="keyword">int</span> fat)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(servingSize, servings, calories, fat, <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">NutritionFacts</span><span class="params">(<span class="keyword">int</span> servingSize, <span class="keyword">int</span> servings, <span class="keyword">int</span> calories, <span class="keyword">int</span> fat,</span></span></div><div class="line"><span class="function"><span class="params">                      <span class="keyword">int</span> sodium)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(servingSize, servings, calories, fat, sodium, <span class="number">0</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">NutritionFacts</span><span class="params">(<span class="keyword">int</span> servingSize, <span class="keyword">int</span> servings, <span class="keyword">int</span> calories, <span class="keyword">int</span> fat,</span></span></div><div class="line"><span class="function"><span class="params">                      <span class="keyword">int</span> sodium, <span class="keyword">int</span> carbohydrate)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.servingSize = servingSize;</div><div class="line">    <span class="keyword">this</span>.servings = servings;</div><div class="line">    <span class="keyword">this</span>.calories = calories;</div><div class="line">    <span class="keyword">this</span>.fat = fat;</div><div class="line">    <span class="keyword">this</span>.sodium = sodium;</div><div class="line">    <span class="keyword">this</span>.carbohydrate = carbohydrate;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;如上所见，这些构造器可能包含了一些我们并不想设置的参数，但是还是不得不为其传递值，并且，当参数一多，代码就会变得难以阅读，时常出现无法知道某一个值的具体含义，必须仔细对照构造器来查找。伴随着参数的增多，这种方式的构造器将很快是去控制。<br>&nbsp;&nbsp;因此当遇到这种许多构造器参数的时候，可以选用建造者模式。</p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NutritionFacts</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servingSize;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servings;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> calories;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> fat;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> sodium;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> carbohydrate;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">        <span class="comment">// 必要参数</span></div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servingSize;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> servings;</div><div class="line"></div><div class="line">        <span class="comment">// 可选参数</span></div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> calories = <span class="number">0</span>;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> fat = <span class="number">0</span>;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> carbohydrate = <span class="number">0</span>;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> sodium = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(<span class="keyword">int</span> servingSize, <span class="keyword">int</span> servings)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.servingSize = servingSize;</div><div class="line">            <span class="keyword">this</span>.servings = servings;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">calories</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</div><div class="line">            calories = val;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">fat</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</div><div class="line">            fat = val;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">carbohydrate</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</div><div class="line">            carbohydrate = val;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">sodium</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</div><div class="line">            sodium = val;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> NutritionFacts <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NutritionFacts(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">NutritionFacts</span><span class="params">(Builder builder)</span> </span>&#123;</div><div class="line">        servingSize = builder.servingSize;</div><div class="line">        servings = builder.servings;</div><div class="line">        calories = builder.calories;</div><div class="line">        fat = builder.fat;</div><div class="line">        sodium = builder.sodium;</div><div class="line">        carbohydrate = builder.carbohydrate;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        NutritionFacts cocaCola = <span class="keyword">new</span> NutritionFacts.Builder(<span class="number">240</span>, <span class="number">8</span>)</div><div class="line">                .calories(<span class="number">100</span>).sodium(<span class="number">35</span>).carbohydrate(<span class="number">27</span>).build();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;如上代码所示，这样的客户端代码容易编写，并且易于阅读。对于参数值，可以单独设置组合，不再需要传递不必要的参数值。</p>
<h2 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h2><ul>
<li>需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性</li>
<li>构建的过程允许对构建的对象进行不同的表示</li>
</ul>
<h2 id="具体实例"><a href="#具体实例" class="headerlink" title="具体实例"></a>具体实例</h2><ul>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html" target="_blank" rel="external">java.lang.StringBuilder</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html#append-boolean-" target="_blank" rel="external">java.lang.StringBuffer</a></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://github.com/iluwatar/java-design-patterns/tree/master/singleton" target="_blank" rel="external">java-design-patterns</a></li>
<li>《Effective Java 第2版》</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;建造者模式也称为生成器模式，是一种对象创建型模式，它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://zhaoxizhang.github.io/tags/Java/"/>
    
      <category term="设计模式" scheme="https://zhaoxizhang.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式——单例模式（创建型模式）</title>
    <link href="https://zhaoxizhang.github.io/2018/06/14/Java-Design-Patterns-Singleton/"/>
    <id>https://zhaoxizhang.github.io/2018/06/14/Java-Design-Patterns-Singleton/</id>
    <published>2018-06-13T16:00:00.000Z</published>
    <updated>2018-06-14T06:17:23.918Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&nbsp;&nbsp;单例模式保证对于每一个类加载器，一个类仅有一个实例并且提供全局的访问。其是一种对象创建型模式。对于单例模式主要适用以下几个场景：<a id="more"></a></p>
<ul>
<li>系统只需要一个实例对象，如提供一个唯一的序列号生成器</li>
<li>客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例</li>
</ul>
<p>&nbsp;&nbsp;单例模式的缺点之一是在分布式环境中，如果因为单例模式而产生 bugs，那么很难通过调试找出问题所在，因为在单个类加载器下进行调试，并不会出现问题。</p>
<h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><p>&nbsp;&nbsp;一般来说，实现枚举有五种方式：饿汉式、懒汉式、双重锁检验、静态内部类、枚举，而这里我将这五种方式分为三部分来介绍。</p>
<h3 id="饿汉式加载"><a href="#饿汉式加载" class="headerlink" title="饿汉式加载"></a>饿汉式加载</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</div><div class="line">    <span class="comment">//私有构造器，所以无法实例化类对象</span></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="comment">//类静态实例域</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</div><div class="line"></div><div class="line">    <span class="comment">//返回类实例</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> INSTANCE;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>直接初始化静态实例保证了线程安全，但是此种方式不是懒加载的，单例一开始就初始化了，无法在我们需要的时候再进行初始化。</p>
<h3 id="懒汉式加载"><a href="#懒汉式加载" class="headerlink" title="懒汉式加载"></a>懒汉式加载</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//实例在这个方法第一次被调用的时候进行初始化</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">        instance = <span class="keyword">new</span> Singleton();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> instance;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>getInstance()</code>方法设置为<code>synchronized</code>保证了线程安全，但是其效率并不高，因为在任何时候只有一个线程能够访问这个方法，而同步操作仅需在第一次被调用的时候才被需要。</p>
<p>此方法的一种改进是使用双重锁检验。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadSafeDoubleCheckLocking</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> ThreadSafeDoubleCheckLocking instance;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ThreadSafeDoubleCheckLocking</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadSafeDoubleCheckLocking <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="comment">//局部变量可以提高25%的性能，这个局部变量确保instance只在已经被初始化的情况下读取一次</span></div><div class="line">        <span class="comment">//《Effective Java 第2版》P250页</span></div><div class="line">        ThreadSafeDoubleCheckLocking result = instance;</div><div class="line">        <span class="comment">//检查实例是否已经别初始化</span></div><div class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">//未被初始化，但是无法确定这时其他线程是否已经对其初始化，因此添加对象锁进行互斥</span></div><div class="line">            <span class="keyword">synchronized</span> (ThreadSafeDoubleCheckLocking.class) &#123;</div><div class="line">                <span class="comment">//再一次将instance赋值给局部变量来进行检查，因为有可能在当前线程阻塞的时候，其他线程对instance进行初始化</span></div><div class="line">                result = instance;</div><div class="line">                <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</div><div class="line">                    <span class="comment">//此时还未被初始化的话，在这里初始化可以保证线程安全</span></div><div class="line">                    instance = result = <span class="keyword">new</span> ThreadSafeDoubleCheckLocking();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面的双重锁检验使用了《Effective Java 第2版》提出的一个优化方式，另外值得一提的是，对于<code>instance</code>域被声明为<code>volatile</code>是很重要的。当一个变量定义为<code>volatile</code>之后，它就具备了两种特性，第一是保证了此变量对所有线程的可见性，“可见性”指的是当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的（注意基于volatile变量的运算在并发编程下并非是安全的，例如：假设被volatile修饰的域进行自增运算，而自增运算并不是原子操作，那么第二个线程就可能在读取旧值和写回新值的期间读取到这个域，导致第二个线程看到的值与第一个线程未自增前的值一样，详细了解的话可查看《深入理解Java虚拟机 第2版》P366 基于volatile型变量的特殊规则）；第二是禁止指令重排序优化。<br>在进行初始化的时候<code>instance = result = new ThreadSafeDoubleCheckLocking()</code>，此时 JVM 大致做了三件事：</p>
<ul>
<li>1.给instance分配内存</li>
<li>2.调用构造函数进行初始化</li>
<li>3.instance对象指向被分配的内存</li>
</ul>
<p>没有声明为<code>volatile</code>，那么指令重排序后，可能执行的顺序是 1-3-2，当线程一执行到3这个步骤，还未执行步骤2（instance非null，但未初始化），那么对于线程二，此时检测到 instance 并非是 null，直接返回 instance，就会出现错误。需要说明的一点是，JDK 1.5以后，<code>volatile</code>才真正发挥用处，因此在1.5以前，仍然是无法保证安全的，具体可查看 <a href="http://www.cs.umd.edu/~pugh/java/memoryModel/DoubleCheckedLocking.html" target="_blank" rel="external">The “Double-Checked Locking is Broken” Declaration</a>.</p>
<p>另外一种懒加载方式就是使用静态内部类的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitializingOnDemandHolderIdiom</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">InitializingOnDemandHolderIdiom</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InitializingOnDemandHolderIdiom <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> HelperHolder.INSTANCE;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HelperHolder</span> </span>&#123;</div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InitializingOnDemandHolderIdiom INSTANCE =</div><div class="line">                <span class="keyword">new</span> InitializingOnDemandHolderIdiom();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这种方式是线程安全的，同时也是懒加载的。<code>HelperHolder</code>是私有的，除了<code>getInstance()</code>外没有办法访问。这种方式不需要依赖其他语言特性（volatile，synchronized），也不依赖JDK版本。</p>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>《Effective Java 第2版》P15 中提到实现单例的一种新方式，使用枚举来实现单例。枚举类型是Java 5中新增特性的一部分，因此使用这种方式实现的枚举，要求至少是 JDK 1.5版本及其以上。枚举本身保证了线程安全，并且提供了序列化机制，因此这种方式写起来极为简洁。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</div><div class="line">    INSTANCE;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然，对于使用枚举来实现单例模式也有一些缺点，具体可以查看 <a href="https://softwareengineering.stackexchange.com/questions/179386/what-are-the-downsides-of-implementing-a-singleton-with-javas-enum" target="_blank" rel="external">StackOverflow</a> 的讨论。</p>
<h2 id="典型使用场景"><a href="#典型使用场景" class="headerlink" title="典型使用场景"></a>典型使用场景</h2><ul>
<li>日志纪录类</li>
<li>管理与数据库的连接</li>
<li>文件管理系统</li>
</ul>
<h2 id="具体实例"><a href="#具体实例" class="headerlink" title="具体实例"></a>具体实例</h2><p><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Runtime.html#getRuntime%28%29" target="_blank" rel="external">java.lang.Runtime#getRuntime()</a><br><a href="https://docs.oracle.com/javase/8/docs/api/java/awt/Desktop.html#getDesktop--" target="_blank" rel="external">java.awt.Desktop#getDesktop()</a><br><a href="https://docs.oracle.com/javase/8/docs/api/java/lang/System.html#getSecurityManager--" target="_blank" rel="external">java.lang.System#getSecurityManager()</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://github.com/iluwatar/java-design-patterns/tree/master/singleton" target="_blank" rel="external">java-design-patterns</a></li>
<li>《Effective Java 第2版》</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;单例模式保证对于每一个类加载器，一个类仅有一个实例并且提供全局的访问。其是一种对象创建型模式。对于单例模式主要适用以下几个场景：
    
    </summary>
    
    
      <category term="Java" scheme="https://zhaoxizhang.github.io/tags/Java/"/>
    
      <category term="设计模式" scheme="https://zhaoxizhang.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java中static的用法</title>
    <link href="https://zhaoxizhang.github.io/2018/05/31/The-use-of-static-in-Java/"/>
    <id>https://zhaoxizhang.github.io/2018/05/31/The-use-of-static-in-Java/</id>
    <published>2018-05-30T16:00:00.000Z</published>
    <updated>2018-06-07T08:30:09.033Z</updated>
    
    <content type="html"><![CDATA[<h2 id="静态域"><a href="#静态域" class="headerlink" title="静态域"></a>静态域</h2><p>&nbsp;&nbsp;如果将域定义为 static，每个类中只有一个这样的域。而每一个对象对于所有的实例域却都有自己的一份拷贝。例如，假定需要给每一个雇员赋予唯一的标识码，这里给 Employee 类添加一个实例域 id 和一个静态域 nextId：<br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> nextId = <span class="number">1</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;现在，每一个雇员对象都有一个自己的 id 域，但这个类的所有实例将共享一个 nextId。nextId 属于类，而不属于任何一个对象，没有对象的存在，静态域 nextId 也存在。<br>&nbsp;&nbsp;对于静态变量，静态常量在 Java 中更为常见，我们平常中比较熟悉的 Math 类中就定义有静态常量供我们直接使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span></span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> E = <span class="number">2.7182818284590452354</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.14159265358979323846</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于静态域，其使用场景一般用于：</p>
<ul>
<li>在对象之间共享数据</li>
<li>方便访问</li>
</ul>
<h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>&nbsp;&nbsp;同样，我们仍然可以在 Math 类中看到很多的静态方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">sin</span><span class="params">(<span class="keyword">double</span> a)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> StrictMath.sin(a);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">cos</span><span class="params">(<span class="keyword">double</span> a)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> StrictMath.cos(a);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;对于静态方法的调用，我们可以使用“类名.方法名”的方式，也可以使用“对象名.方法名”的方式调用，静态方法在访问本类的成员的时候，只允许访问静态成员（即静态变（常）量和静态方法），而不允许访问实例成员，因为实例成员与具体的对象关联，而静态方法属于类，不与任何对象绑定。</p>
<h2 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h2><p>&nbsp;&nbsp;可以将多个静态初始化动作组织成一个特殊的“静态子句”构成静态代码块：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">static</span>&#123;</div><div class="line">        i = <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>对于上述代码，实际就是一段跟在 static 关键字后面的代码，与其他静态初始化动作一样，这段代码只执行一次：当首次生成这个类的一个对象时，或者首次访问属于那个类的静态数据成员时（即便从未生成过那个类的对象）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cup</span></span>&#123;</div><div class="line">    Cup(<span class="keyword">int</span> marker)&#123;</div><div class="line">        System.out.println(<span class="string">"Cup("</span> + marker + <span class="string">")"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> marker)</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"f("</span> + marker + <span class="string">")"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cups</span></span>&#123;</div><div class="line">    <span class="keyword">static</span> Cup cup1;</div><div class="line">    <span class="keyword">static</span> Cup cup2;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String HELLOWORLD = <span class="string">"hello world"</span>;</div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        cup1 = <span class="keyword">new</span> Cup(<span class="number">1</span>);</div><div class="line">        cup2 = <span class="keyword">new</span> Cup(<span class="number">2</span>);</div><div class="line">    &#125;</div><div class="line">    Cups()&#123;</div><div class="line">        System.out.println(<span class="string">"Cups()"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExplicitStatic</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... args)</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"Inside main()"</span>);</div><div class="line">        <span class="comment">//Cups.cup1.f(99);   //(1)</span></div><div class="line">        <span class="comment">//Cups cups = new Cups();  //(2)</span></div><div class="line">        System.out.println(Cups.HELLOWORLD);  <span class="comment">//(3)</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*执行（1）处的代码，其输出如下：</span></div><div class="line"><span class="comment">    Inside main()</span></div><div class="line"><span class="comment">    Cup(1)</span></div><div class="line"><span class="comment">    Cup(2)</span></div><div class="line"><span class="comment">    f(99)</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">执行（2）处的代码，其输出如下：</span></div><div class="line"><span class="comment">    Inside main()</span></div><div class="line"><span class="comment">    Cup(1)</span></div><div class="line"><span class="comment">    Cup(2)</span></div><div class="line"><span class="comment">    Cups()</span></div><div class="line"><span class="comment">执行（3）处的代码，其输出如下：</span></div><div class="line"><span class="comment">    Inside main()</span></div><div class="line"><span class="comment">    hello world</span></div><div class="line"><span class="comment">*/</span></div></pre></td></tr></table></figure></p>
<p>值得注意的是，对于执行（2）的代码，<strong>静态代码块中的内容优于构造器先执行</strong>。另外，如果（1），（2）的代码都不执行，那么静态代码块中的代码也不会得到执行。<br>此外，可能令人不解的是，对于执行（3）处的代码，其为什么没有输出静态代码块中的内容？这是因为虽然在Java源码中引用了 Cups 类中的常量 HELLOWORLD，但其实在编译阶段通过常量传播优化，已经将此常量的值“hello world”存储到了 ExpliciStatic 类的常量池，以后 ExpliciStatic 对常量 Cups.HELLOWORLD 的引用实际都转化为 ExpliciStatic 类对自身常量池的引用了。这点在《深入理解Java虚拟机》中虚拟机类加载机制一章中有进行阐述。</p>
<h2 id="static与final"><a href="#static与final" class="headerlink" title="static与final"></a>static与final</h2><p>static与final连用修饰成员，一般作为全局常量使用，其修饰的变量无法修改，修饰的方法无法被覆盖。</p>
<h2 id="static常见面试题"><a href="#static常见面试题" class="headerlink" title="static常见面试题"></a>static常见面试题</h2><ul>
<li>非静态内部类里面为什么不能有静态属性和静态方法<br>static 类型的属性和方法在类加载的时候就会存在于内存中，要使用某个类的 static 属性或者方法的前提是这个类已经加载到 JVM 中，非 static 内部类默认是持有外部类的引用且依赖外部类存在，所以如果一个非 static 的内部类一旦具有 static 的属性或者方法就会出现内部类未加载时却试图在内存中创建内部类的 static 属性和方法，这自然是错误的，类都不存在（没被加载）却希望操作它的属性和方法。从另一个角度讲非 static 的内部类在实例化的时候才会加载（不自动跟随主类加载），而 static 的语义是类能直接通过类名来访问类的 static 属性或者方法，所以如果没有实例化非 static 的内部类就等于非 static 的内部类没有被加载，所以无从谈起通过类名访问 static 属性或者方法。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;静态域&quot;&gt;&lt;a href=&quot;#静态域&quot; class=&quot;headerlink&quot; title=&quot;静态域&quot;&gt;&lt;/a&gt;静态域&lt;/h2&gt;&lt;p&gt;&amp;nbsp;&amp;nbsp;如果将域定义为 static，每个类中只有一个这样的域。而每一个对象对于所有的实例域却都有自己的一份拷贝。例如，假定需要给每一个雇员赋予唯一的标识码，这里给 Employee 类添加一个实例域 id 和一个静态域 nextId：&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://zhaoxizhang.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>减小APK大小</title>
    <link href="https://zhaoxizhang.github.io/2018/04/21/Reduce-apk-size/"/>
    <id>https://zhaoxizhang.github.io/2018/04/21/Reduce-apk-size/</id>
    <published>2018-04-20T16:00:00.000Z</published>
    <updated>2018-11-06T14:22:30.627Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章翻译自<a href="https://developer.android.com/topic/performance/reduce-apk-size.html#apk-structure" target="_blank" rel="external">Reduce APK Size</a></p>
<p>  用户通常不会去下载体积过大的应用程序，特别是当自己的设备连接的是 2G/3G 或者按字节付费的网络。这篇文章描述了如何缩减 APK 的体积大小，以使得更多用户愿意下载你开发的应用。<br><a id="more"></a></p>
<h2 id="了解APK结构"><a href="#了解APK结构" class="headerlink" title="了解APK结构"></a>了解APK结构</h2><p>  在讨论如何缩减你应用的体积之前，了解 APK 结构是非常有益处的。一个 APK 文件包含了一个 ZIP 文件，该 ZIP 文件包含了组成你应用的所有文件，这些文件包括 Java 字节码文件、资源文件和已编译资源的文件。<br>APK 包含下列目录：</p>
<ul>
<li><code>META-INF/</code>：包含了<code>CERT.SF</code>、<code>CERT.RSA</code>签名文件以及<code>MAINFEST.MF</code>mainfest文件</li>
<li><code>assets/</code>：包含了应用程序的资源，应用程序可以通过 <a href="https://developer.android.com/reference/android/content/res/AssetManager.html" target="_blank" rel="external">AssetManager</a> 检索资源</li>
<li><code>res/</code>：包含了没有编译到<code>resources.arsc</code>的资源</li>
<li><code>lib/</code>：包含了特定处理器的软件层的编译代码，该目录包含了每个平台类型的子目录，例如<code>armeabi</code>、<code>armeabi-v7a</code>、<code>arm64-v8a</code>、<code>x86</code>、<code>x86_64</code>和<code>mips</code></li>
</ul>
<p>APK 也包含了下列文件，在这些文件之中，只有<code>Mainfest.xml</code>是强制的</p>
<ul>
<li><code>resources.arsc</code>：包含了编译的资源，该文件包含了来自<code>res/values/</code>目录下所有配置的XML内容。打包工具提取此XML内容，将其编译为二进制格式，并归档内容。此内容包含了语言字符串和样式，以及未直接包含在<code>resources.arsc</code>文件中的内容路径，比如布局文件和图像。<br><code>classes.dex</code>：包含了能被<code>Dalvik/ART</code>虚拟机识别的 DEX 文件格式编译的类<br><code>AndroidManifest.xml</code>：包含了 Android 核心的 mainfest 文件。该文件罗列了应用程序的名字、版本、权限和引用的第三方库。该文件使用 Android 的二进制 XML 格式</li>
</ul>
<h2 id="减少资源数量和大小"><a href="#减少资源数量和大小" class="headerlink" title="减少资源数量和大小"></a>减少资源数量和大小</h2><p>  APK 的大小会影响到应用程序启动的速度、使用的内存和消耗的电量。缩减应用程序大小最简单的方式之一就是减少它所包含的资源数量和大小。特别是你可以移除你的应用中不再使用的资源，或者使用可拓展的 <a href="https://developer.android.com/reference/android/graphics/drawable/Drawable.html" target="_blank" rel="external">Drawable</a>  对象来替代图像文件。这部分讨论的这些方法以及一些其他的方式可以减少你应用程序中的资源从而在整体上减少 APK 体积的大小。</p>
<h3 id="移除无用的资源"><a href="#移除无用的资源" class="headerlink" title="移除无用的资源"></a>移除无用的资源</h3><p>Android Studio中的静态代码检查工具——<a href="https://developer.android.com/studio/write/lint.html" target="_blank" rel="external">lint</a>可以检测<code>res/</code>目录下没有引用的资源。当 lint 检查工具发现在你项目中可能存在一个没有使用的资源，它将会打印出类似如下的信息：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">res<span class="regexp">/layout/</span>preferences.xml: Warning: The resource R.layout.preferences appears</div><div class="line">    to be unused [UnusedResources]</div></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：lint 检查工具没有扫描<code>assets/</code>目录，assets 资源是通过反射的方式，或者链接到应用程序的库文件来发现引用的。此外，lint 检查工具并不删除这些资源，它只是提醒你它们的存在。</p>
</blockquote>
<p>你使用的一些库可能包含了一些无用的资源，如果你在 <code>build.gradle</code>文件中开启了 <a href="https://developer.android.com/studio/build/shrink-code.html" target="_blank" rel="external">shrinkResources</a>，那么 Gradle 可以帮你自动移除这些资源。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line">    <span class="comment">// Other settings</span></div><div class="line"></div><div class="line">    buildTypes &#123;</div><div class="line">        release &#123;</div><div class="line">            minifyEnabled <span class="literal">true</span></div><div class="line">            shrinkResources <span class="literal">true</span></div><div class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>要使用 shrinkResources，你必须启用代码缩减。在编译的过程，首先 <a href="https://developer.android.com/studio/build/shrink-code.html" target="_blank" rel="external">ProGuard</a> 移除无用的代码但是并不移除无用的资源，之后由 Gradle 移除无用的资源。<br>更多有关 ProGuard 和其他一些通过 Android Studio帮助你缩减 APK 体积大小的方法，可以查看<a href="https://developer.android.com/studio/build/shrink-code.html" target="_blank" rel="external">压缩代码和资源</a></p>
<h3 id="最小化库中资源的使用"><a href="#最小化库中资源的使用" class="headerlink" title="最小化库中资源的使用"></a>最小化库中资源的使用</h3><p>当开发一个 Android 应用的时候，通常会使用一些第三方库来提高应用程序的可用性和多功能性。比如，可能使用了 <a href="https://developer.android.com/topic/libraries/support-library/index.html" target="_blank" rel="external">Android Support Library</a> 来改善在旧机型上的用户体验，或者使用 <a href="https://developers.google.com/android/guides/overview" target="_blank" rel="external">Google Play Services</a> 为应用程序提供自动翻译。<br>如果一个库是为服务器或者桌面设计的，那么它通常包含了许多你的应用程序用不到的对象和方法，如果这个库所使用的协议允许，那么你可以修改这个库文件。当然，你也可以使用其他一些对于移动端友好的库来为你的应用程序添加特定功能。</p>
<blockquote>
<p>注意：ProGuard 可以清理第三方库中对你应用非必须的代码，但是它不能移除第三方库的大型内部依赖项。</p>
</blockquote>
<h3 id="只支持特定的分辨率"><a href="#只支持特定的分辨率" class="headerlink" title="只支持特定的分辨率"></a>只支持特定的分辨率</h3><p>Android 支持非常大的设备集，拥有着各式各样的分辨率。在 Android4.4（API level 19）或者更高的系统版本，其框架支持许多分辨率：<code>ldpi</code>、<code>mdpi</code>、<code>tvdpi</code>、<code>hdpi</code>、<code>xhdpi</code>、<code>xxhdpi</code>。尽管 Android 支持所有这些分辨率，但是你并不需要适配每一种分辨率。<br>如果你知道你的用户群中只有一小部分使用具有特定分辨率的设备，考虑你是否需要适配这些分辨率。如果你没有为特定分辨率准备资源文件，那么 Android 将自动缩放最初为其他屏幕分辨率设计的现有资源。<br>如果你的应用程序只需要缩放的图片，你可以通过在 <code>drawable-nodpi</code>目录中使用图片的单个版本来节省更多的空间。我们建议每个应用程序至少包含一个<code>xxhdpi</code>图片版本。<br>更多有关屏幕分辨率的信息，可以查看<a href="https://developer.android.com/about/dashboards/index.html#Screens" target="_blank" rel="external">屏幕尺寸和密度</a></p>
<h3 id="使用drawable对象"><a href="#使用drawable对象" class="headerlink" title="使用drawable对象"></a>使用drawable对象</h3><p>一些图像并不需要一个静态的图像资源，frameworker 可以在运行时动态的绘制出图像。<a href="https://developer.android.com/reference/android/graphics/drawable/Drawable.html" target="_blank" rel="external">Drawable</a> 对象占用APK中少量空间。此外，XML形式的 <a href="https://developer.android.com/reference/android/graphics/drawable/Drawable.html" target="_blank" rel="external">Drawable</a> 对象可以产生符合<code>Material Design</code>准则的单色图像。</p>
<h3 id="重用资源"><a href="#重用资源" class="headerlink" title="重用资源"></a>重用资源</h3><p>你可以为图像的不同分辨率添加一个单独的资源，比如同一图像的着色、阴影或者旋转版本。但是我们强烈建议你重用相同的资源集，在运行时根据需要定制它们。<br>Android 提供了几个实用程序来更改 asset 的颜色，在 Android5.0（API level 21）或以上版本，可以使用<code>android:tint</code>和<code>tintMode</code>属性。对于较低的系统版本，使用 <a href="https://developer.android.com/reference/android/graphics/ColorFilter.html" target="_blank" rel="external">ColorFilter</a> 类<br>你可以忽略等价于其他资源的资源。下列的代码片段提供了一个例子，通过在图像中间旋转180°将向上的标志转换成向下的标志。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">rotate</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></div><div class="line"><span class="tag">    <span class="attr">android:drawable</span>=<span class="string">"@drawable/ic_thumb_up"</span></span></div><div class="line"><span class="tag">    <span class="attr">android:pivotX</span>=<span class="string">"50%"</span></span></div><div class="line"><span class="tag">    <span class="attr">android:pivotY</span>=<span class="string">"50%"</span></span></div><div class="line"><span class="tag">    <span class="attr">android:fromDegrees</span>=<span class="string">"180"</span> /&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="从代码中呈现"><a href="#从代码中呈现" class="headerlink" title="从代码中呈现"></a>从代码中呈现</h3><p>我们还可以通过程序化渲染图像来缩减 APK 的体积大小。程序化渲染可以释放空间，因为你不再在APK中保存图像文件。</p>
<h3 id="压缩PNG文件"><a href="#压缩PNG文件" class="headerlink" title="压缩PNG文件"></a>压缩PNG文件</h3><p><code>aapt</code>工具在编译的过程可以无损压缩存放在<code>res/drawable/</code>目录下的资源。例如，<code>aapt</code>工具可以将不需要超过256种颜色的真彩色PNG转换为具有调色板的8位PNG。 这样会产生质量相同的图像，但内存占用空间更小。<br>记住aapt有以下限制：</p>
<ul>
<li>aapt工具不能压缩<code>asset</code>目录下的PNG文件</li>
<li>aapt工具只能优化使用不多于256位颜色的图像文件</li>
<li>aapt工具可能会填充已经压缩过的PNG图像，为了防止这种情况，你可以使用 Gradle 中的<code>cruncherEnabled</code>标志来禁用 PNG 文件的这个过程。<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">aaptOptions &#123;</div><div class="line">    cruncherEnabled = false</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="压缩PNG和JPEG文件"><a href="#压缩PNG和JPEG文件" class="headerlink" title="压缩PNG和JPEG文件"></a>压缩PNG和JPEG文件</h3><p>你可以使用类似 <a href="https://pmt.sourceforge.io/pngcrush/" target="_blank" rel="external">pngcrush</a>、<a href="https://pngquant.org/" target="_blank" rel="external">pngquant</a> 或者 <a href="https://github.com/google/zopfli" target="_blank" rel="external">zopflipng</a> 等工具来无损压缩 PNG 文件。所有这些工具都可以压缩 PNG 同时保持图像质量。<br>pngcrush 工具特别有效：这个工具通过使用过滤器和参数的各种组合来压缩图像，在 PNG 过滤器和 zlib(Deflate) 参数上迭代。它选择最小压缩输出的配置。<br>对于 JPEG 图像，你可以使用类似 <a href="http://www.elektronik.htw-aalen.de/packjpg/" target="_blank" rel="external">packJPG</a> 和 <a href="https://github.com/google/guetzli" target="_blank" rel="external">guetzli</a> 的工具来压缩。</p>
<h3 id="使用WebP文件格式"><a href="#使用WebP文件格式" class="headerlink" title="使用WebP文件格式"></a>使用WebP文件格式</h3><p>在Android 3.2（API level 13）或更高版本，除了使用 PNG 或 JPEG 格式的图像文件，你还可以使用 <a href="https://developers.google.com/speed/webp/" target="_blank" rel="external">WebP</a> 文件格式的图像。WebP 格式提供有损压缩（类似于JPEG）以及透明度（类似于PNG），但是能更好的提供比 JPEG 或 PNG 更好的压缩效果。<br>你可以使用 Android Studio 转换 BMP、JPG、PNG或者静态GIF的图像为 WebP 格式。获取更多信息，查看<a href="https://developer.android.com/studio/write/convert-webp.html" target="_blank" rel="external">创建WebP图像</a></p>
<blockquote>
<p>注意：Google Play 只接受<a href="https://material.io/guidelines/style/icons.html#" target="_blank" rel="external">启动图标</a>为 PNG 格式的 APKs</p>
</blockquote>
<h3 id="使用矢量图形"><a href="#使用矢量图形" class="headerlink" title="使用矢量图形"></a>使用矢量图形</h3><p>你可以使用矢量图形创建独立于分辨率的图标和其他可伸缩图片。 使用这些图形可以大大减少APK的大小。矢量图形在 Android 中表示为 <a href="https://developer.android.com/reference/android/graphics/drawable/VectorDrawable.html" target="_blank" rel="external">VectorDrawable</a> 对象。使用 <a href="https://developer.android.com/reference/android/graphics/drawable/VectorDrawable.html" target="_blank" rel="external">VectorDrawable</a> 对象，100字节的文件可以生成屏幕大小的清晰图像。<br>但是系统将会花费大量时间去渲染 <a href="https://developer.android.com/reference/android/graphics/drawable/VectorDrawable.html" target="_blank" rel="external">VectorDrawable</a> 对象，对于大的图像需要更长的时间才能出现在屏幕上。因此，在展示小图像的时候再考虑矢量图。<br>获取更多有关 <a href="https://developer.android.com/reference/android/graphics/drawable/VectorDrawable.html" target="_blank" rel="external">VectorDrawable</a> 对象的信息，查看<a href="https://developer.android.com/training/material/drawables.html" target="_blank" rel="external">使用图片</a></p>
<h3 id="使用矢量图形制作动画图像"><a href="#使用矢量图形制作动画图像" class="headerlink" title="使用矢量图形制作动画图像"></a>使用矢量图形制作动画图像</h3><p>不要使用 <a href="https://developer.android.com/reference/android/graphics/drawable/AnimationDrawable.html" target="_blank" rel="external">AnimationDrawable</a> 去创建逐帧动画，因为这样做需要为动画的每个帧添加单独的位图文件，这会增加 APK 的体积大小。<br>你可以使用 <a href="https://developer.android.com/reference/android/support/graphics/drawable/AnimatedVectorDrawableCompat.html" target="_blank" rel="external">AnimatedVectorDrawable</a> 为<a href="https://developer.android.com/training/material/animations.html#AnimVector" target="_blank" rel="external">矢量图片添加动画</a></p>
<h2 id="减少Native和Java代码"><a href="#减少Native和Java代码" class="headerlink" title="减少Native和Java代码"></a>减少Native和Java代码</h2><p>你可以使用下列几种方式去减少应用程序中的 Java 和 native 代码库。</p>
<h3 id="移除不必要的生成代码"><a href="#移除不必要的生成代码" class="headerlink" title="移除不必要的生成代码"></a>移除不必要的生成代码</h3><p>确保了解自动生成的代码的足迹。例如，许多协议缓冲工具生成过多的方法和类，这可能使应用程序的大小增加一倍或者两倍。</p>
<h3 id="避免枚举"><a href="#避免枚举" class="headerlink" title="避免枚举"></a>避免枚举</h3><p>一个枚举可以为你的应用程序的<code>classes.dex</code>文件增加1.0至1.4KB的大小，对于复杂系统或者共享库，这些将快速累积。如果可能的话，考虑使用<code>@IntDef</code>注解和 <a href="https://developer.android.com/studio/build/shrink-code.html" target="_blank" rel="external">ProGuard</a> 来除去枚举并将它们转换为整数。这种类型转换保留了枚举的所有类型安全的好处。</p>
<h3 id="减小本地二进制文件的大小"><a href="#减小本地二进制文件的大小" class="headerlink" title="减小本地二进制文件的大小"></a>减小本地二进制文件的大小</h3><p>如果你的应用程序使用 native code 和 Android NDK，你可以通过优化代码来减少应用程序的体积大小。两种有用的技术是删除调试符号和避免提取本地库。</p>
<ul>
<li>删除调试符号<br>如果你的应用程序正在开发并且需要调试，那么使用调试符号是很有意义的。使用 Android NDK 提供的<code>arm-eabi-strip</code>工具去移除本地库中不必要的调试符号，之后再进行 release版本的编译。</li>
<li>避免提取本地库<br>将<code>.so</code>文件保存在 APK 中未压缩的文件，设置<code> application </code>中的元素<code>android:extracNativeLibs</code>为false，这将防止 <a href="https://developer.android.com/reference/android/content/pm/PackageManager.html" target="_blank" rel="external">PackageManager</a> 在安装过程中将<code>.so</code>文件从APK复制到文件系统，并且有一个额外的好处，使得应用程序的增量更新更小。</li>
</ul>
<h2 id="维护多个精简版APK"><a href="#维护多个精简版APK" class="headerlink" title="维护多个精简版APK"></a>维护多个精简版APK</h2><p>你的 APK 可以包含用户下载但从未使用的内容，例如区域或语言信息。为了让用户下载尽量小的应用程序，你可以将你的应用程序根据屏幕尺寸或GPU纹理支持等因素细分为多个 APKs。<br>当用户下载你的应用程序的时候，根据他们的设备特点以及设置详情，他们会接收到正确的 APK，这样，设备不会接收设备没有的功能的资源。例如，一个用户有<code>hdpi</code>的设备，他们不需要为更高分辨率的设备提供的<code>xxxhdpi</code>的资源。<br>获取更多相关信息，可以查看 <a href="https://developer.android.com/studio/build/configure-apk-splits.html" target="_blank" rel="external">Configure APK Splits</a> 和 <a href="https://developer.android.com/google/play/publishing/multiple-apks.html" target="_blank" rel="external"> Maintaining Multiple APKs</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章翻译自&lt;a href=&quot;https://developer.android.com/topic/performance/reduce-apk-size.html#apk-structure&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Reduce APK Size&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;  用户通常不会去下载体积过大的应用程序，特别是当自己的设备连接的是 2G/3G 或者按字节付费的网络。这篇文章描述了如何缩减 APK 的体积大小，以使得更多用户愿意下载你开发的应用。&lt;br&gt;
    
    </summary>
    
    
      <category term="Android——性能优化" scheme="https://zhaoxizhang.github.io/tags/Android%E2%80%94%E2%80%94%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Java 8新特性</title>
    <link href="https://zhaoxizhang.github.io/2018/04/20/Java8-tutorial/"/>
    <id>https://zhaoxizhang.github.io/2018/04/20/Java8-tutorial/</id>
    <published>2018-04-19T16:00:00.000Z</published>
    <updated>2018-11-06T16:42:12.712Z</updated>
    
    <content type="html"><![CDATA[<p>本文译自<a href="https://github.com/winterbe/java8-tutorial" target="_blank" rel="external">Java8-tutorial</a>，并对其中内容进行了一些修改和补充。<br><a id="more"></a></p>
<h2 id="接口的默认方法"><a href="#接口的默认方法" class="headerlink" title="接口的默认方法"></a>接口的默认方法</h2><p>在 Java 8 中，我们可以通过<code>default</code>关键字来为接口添加非抽象方法。<code>default</code>关键字修饰的方法称为默认方法，它允许我们添加新的功能到现有库的接口中，并能确保与采用旧版本接口编写的代码之间相互兼容。<br>对于以下例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Formula</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">double</span> <span class="title">sqrt</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> Math.sqrt(a);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在<code>Formula</code>接口中，除了有抽象方法<code>calculate</code>，还定义了默认方法<code>sqrt</code>，<code>Formula</code>的实现类只需实现抽象方法<code>calculate</code>，默认方法<code>sqrt</code>可直接使用接口中的定义，也可以在具体类中重写。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Formula formula = <span class="keyword">new</span> Formula() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculate</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> sqrt(a * <span class="number">100</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">formula.calculate(<span class="number">100</span>);     <span class="comment">// 100.0</span></div><div class="line">formula.sqrt(<span class="number">16</span>);           <span class="comment">// 4.0</span></div></pre></td></tr></table></figure></p>
<p>上面的代码中，formula 以匿名对象的方式实现了<code>Formula</code>接口，而这只是为了实现<code>sqrt(a * 100)</code>，略显繁琐的，在下一部分，将讨论一种在 Java 8 中更为优雅的实现方式。</p>
<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>首先让我们用 1.8 之前的 Java 版本来对一串字符串进行排序：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; names = Arrays.asList(<span class="string">"peter"</span>, <span class="string">"anna"</span>, <span class="string">"mike"</span>, <span class="string">"xenia"</span>);</div><div class="line"></div><div class="line">Collections.sort(names, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String a, String b)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> b.compareTo(a);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>静态工具方法<code>Collections.sort</code>接受一个列表和一个比较器来对给定的列表中的元素进行排序，你会发现你经常需要创建匿名比较器传给排序函数。<br>为了避免一直创建匿名对象，Java 8 通过<strong>lambad 表达式</strong>来简化语法规则：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Collections.sort(names, (String a, String b) -&gt; &#123;</div><div class="line">    <span class="keyword">return</span> b.compareTo(a);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>上面的代码更加精简，可读性也更强，当然，还可以继续精简：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));</div></pre></td></tr></table></figure></p>
<p>Lambda 表达式的主体只有一条语句时，花括号{}和<code>return</code>关键字可省略。<br>现在，列表有了一个<code>sort</code>方法，另外，当可以从上下文推断出参数的类型，同样可以省略掉参数类型。</p>
<h3 id="Lambad表达式的结构"><a href="#Lambad表达式的结构" class="headerlink" title="Lambad表达式的结构"></a>Lambad表达式的结构</h3><ul>
<li>一个 Lambda 表达式可以有零个或多个参数</li>
<li>参数的类型既可以明确声明，也可以根据上下文来推断。例如：(int a)与(a)效果相同</li>
<li>所有参数需包含在圆括号内，参数之间用逗号相隔。例如：(a, b) 或 (int a, int b) 或 (String a, int b, float c)</li>
<li>空圆括号代表参数集为空。例如：() -&gt; 42</li>
<li>当只有一个参数，且其类型可推导时，圆括号（）可省略。例如：a -&gt; return a*a</li>
<li>Lambda 表达式的主体可包含零条或多条语句</li>
<li>如果 Lambda 表达式的主体只有一条语句，花括号{}可省略。匿名函数的返回类型与该主体表达式一致</li>
<li>如果 Lambda 表达式的主体包含一条以上语句，则表达式必须包含在花括号{}中（形成代码块）。匿名函数的返回类型与代码块的返回类型一致，若没有返回则为空</li>
</ul>
<h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>Lambda 表达式如何匹配 Java 的类型系统的呢？每个 Lambda 对应一个特定的接口，与一个给定的类型相匹配，一个所谓的函数式接口只包含一个抽象方法声明，每个 Lambda 表达式都与那个类型的抽象方法匹配。因为默认方法并非抽象的，因此我们可以向函数式接口任意添加默认方法。<br>我们可以使用任意只包含一个抽象方法声明的接口来作为 Lambda 表达式，为了确保使用的是函数式接口，我们可以添加<code>@FunctionalInterface</code>注解，编译器就会察觉到这个注解，并且当我们尝试往函数式接口添加第二个抽象方法声明时抛出异常。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">F</span>, <span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="function">T <span class="title">convert</span><span class="params">(F from)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Converter&lt;String, Integer&gt; converter = (from) -&gt; Integer.valueOf(from);</div><div class="line">Integer converted = converter.convert(<span class="string">"123"</span>);</div><div class="line">System.out.println(converted);    <span class="comment">// 123</span></div></pre></td></tr></table></figure></p>
<p>假使没有<code>@FunctionalInterface</code>注解，上述代码仍然是正确的。</p>
<h2 id="方法和构造器引用"><a href="#方法和构造器引用" class="headerlink" title="方法和构造器引用"></a>方法和构造器引用</h2><p>方法引用的分类：</p>
<ul>
<li>类名::静态方法名</li>
<li>对象::实例方法名</li>
<li>类名::实例方法名</li>
<li>类名::new</li>
</ul>
<h3 id="类名-静态方法名"><a href="#类名-静态方法名" class="headerlink" title="类名::静态方法名"></a>类名::静态方法名</h3><p>上述例子中的代码可以进一步通过静态方法引用来精简：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Converter&lt;String, Integer&gt; converter = Integer::valueOf;</div><div class="line">Integer converted = converter.convert(<span class="string">"123"</span>);</div><div class="line">System.out.println(converted);   <span class="comment">// 123</span></div></pre></td></tr></table></figure></p>
<p>Java 8 中你可以通过<code>::</code>关键字来传递方法或者构造器引用，上述的例子说明了如何引用一个静态方法。</p>
<h3 id="对象-实例方法名"><a href="#对象-实例方法名" class="headerlink" title="对象::实例方法名"></a>对象::实例方法名</h3><p>我们也可以引用一个对象方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Something</span> </span>&#123;</div><div class="line">    <span class="function">String <span class="title">startsWith</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> String.valueOf(s.charAt(<span class="number">0</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Something something = <span class="keyword">new</span> Something();</div><div class="line">Converter&lt;String, String&gt; converter = something::startsWith;</div><div class="line">String converted = converter.convert(<span class="string">"Java"</span>);</div><div class="line">System.out.println(converted);    <span class="comment">// "J"</span></div></pre></td></tr></table></figure>
<h3 id="类名-实例方法名"><a href="#类名-实例方法名" class="headerlink" title="类名::实例方法名"></a>类名::实例方法名</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareByScore</span><span class="params">(Student student)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getScore() - student.getScore();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">students.sort(Student::compareByScore);</div><div class="line">students.forEach(student -&gt; System.out.println(student.getScore()));</div></pre></td></tr></table></figure>
<p>sort 方法接收的 Lambda 表达式本该有两个参数，而这个实例方法只有一个参数也满足 Lambda 表达式的定义。这就是 类名::实例方法名 这种方法引用的特殊之处，当使用 类名::实例方法名 方法引用时，一定是 Lambda 表达式所接收的第一个参数来调用实例方法，如果 Lambda 表达式接收多个参数，其余的参数作为方法的参数传递进去。</p>
<h3 id="类名-new"><a href="#类名-new" class="headerlink" title="类名::new"></a>类名::new</h3><p>让我们来看看<code>::</code>关键字在构造器引用中是如何使用的。首先，我们定义一个有多个构造函数的类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">    String firstName;</div><div class="line">    String lastName;</div><div class="line"></div><div class="line">    Person() &#123;&#125;</div><div class="line"></div><div class="line">    Person(String firstName, String lastName) &#123;</div><div class="line">        <span class="keyword">this</span>.firstName = firstName;</div><div class="line">        <span class="keyword">this</span>.lastName = lastName;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>接下来，我们创建一个用于创建新人员的工厂接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">PersonFactory</span>&lt;<span class="title">P</span> <span class="keyword">extends</span> <span class="title">Person</span>&gt; </span>&#123;</div><div class="line">    <span class="function">P <span class="title">create</span><span class="params">(String firstName, String lastName)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>除了传统方式实现工厂接口外，通过构造器引用的方式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PersonFactory&lt;Person&gt; personFactory = Person::<span class="keyword">new</span>;</div><div class="line">Person person = personFactory.create(<span class="string">"Peter"</span>, <span class="string">"Parker"</span>);</div></pre></td></tr></table></figure></p>
<p>我们通过<code>Person::new</code>向 Person 构造器传了一个引用（注：Person类中需要有无参构造器），Java编译器会自动选择正确的构造器。</p>
<h2 id="Lambda作用域"><a href="#Lambda作用域" class="headerlink" title="Lambda作用域"></a>Lambda作用域</h2><p>Lambda 表达式访问外部变量的方式与匿名对象非常相似，它可以访问局部外围的 final 变量、成员变量和静态变量。</p>
<h3 id="访问局部变量"><a href="#访问局部变量" class="headerlink" title="访问局部变量"></a>访问局部变量</h3><p>我们可以在 Lambda 表达式所在的外部范围访问<code>final</code>修饰的局部变量<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="keyword">int</span> num = <span class="number">1</span>;</div><div class="line">Converter&lt;Integer, String&gt; stringConverter =</div><div class="line">        (from) -&gt; String.valueOf(from + num);</div><div class="line"></div><div class="line">stringConverter.convert(<span class="number">2</span>);     <span class="comment">// 3</span></div></pre></td></tr></table></figure></p>
<p>不同于匿名对象的是，上述变量 num 不一定要被声明为 final（匿名内部类中的参数必须声明为 final，其值是 capture by value的），下述代码也是正确的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</div><div class="line">Converter&lt;Integer, String&gt; stringConverter =</div><div class="line">        (from) -&gt; String.valueOf(from + num);</div><div class="line"></div><div class="line">stringConverter.convert(<span class="number">2</span>);     <span class="comment">// 3</span></div></pre></td></tr></table></figure></p>
<p>值得注意的是，虽然 num 变量不需要显式声明为 final，但实际上，编译器要求 Lambda 表达式中捕获的变量必须实际上是最终变量（也就是初始化后不可再赋新值）所以 num 不可更改，下述代码无法通过编译，原因就是 num 的值被更改了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</div><div class="line">Converter&lt;Integer, String&gt; stringConverter =</div><div class="line">        (from) -&gt; String.valueOf(from + num);</div><div class="line">num = <span class="number">3</span>;</div></pre></td></tr></table></figure></p>
<h3 id="访问成员变量和静态变量"><a href="#访问成员变量和静态变量" class="headerlink" title="访问成员变量和静态变量"></a>访问成员变量和静态变量</h3><p>与局部变量不同的是，Lambda 表达式中，可以对成员变量和静态变量进行读和写操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lambda4</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">int</span> outerStaticNum;</div><div class="line">    <span class="keyword">int</span> outerNum;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testScopes</span><span class="params">()</span> </span>&#123;</div><div class="line">        Converter&lt;Integer, String&gt; stringConverter1 = (from) -&gt; &#123;</div><div class="line">            outerNum = <span class="number">23</span>;</div><div class="line">            <span class="keyword">return</span> String.valueOf(from);</div><div class="line">        &#125;;</div><div class="line"></div><div class="line">        Converter&lt;Integer, String&gt; stringConverter2 = (from) -&gt; &#123;</div><div class="line">            outerStaticNum = <span class="number">72</span>;</div><div class="line">            <span class="keyword">return</span> String.valueOf(from);</div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="访问接口的默认方法"><a href="#访问接口的默认方法" class="headerlink" title="访问接口的默认方法"></a>访问接口的默认方法</h3><p>在第一部分中关于 formula 的例子，<code>Formula</code>接口定义了一个<code>sqrt</code>的默认方法，其可以被任意一个 formula 实例包括匿名对象访问，但是在 Lambda 表达式中却不行，Lambda 表达式无法访问接口的默认方法，下述代码是错误的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Formula formula = (a) -&gt; sqrt(a * <span class="number">100</span>);</div></pre></td></tr></table></figure></p>
<h2 id="内置函数式接口"><a href="#内置函数式接口" class="headerlink" title="内置函数式接口"></a>内置函数式接口</h2><p>JDK 1.8 API 中包含了很多内置的函数式接口，其中一部分例如<code>Comparator</code>、<code>Runnable</code>在之前的 JDK 版本中就被人熟知。这些现有的接口通过<code>@FunctionalInterface</code>注解被拓展来支持 Lambda。<br>Java 8中的 API 也提供了一些新的函数式接口来使得编程更加简单。<br>以下是常用的函数式接口</p>
<table>
<thead>
<tr>
<th>函数式接口</th>
<th>参数类型</th>
<th>返回类型</th>
<th>抽象方法名</th>
<th>描述</th>
<th>其他方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>Runnable</td>
<td>无</td>
<td>void</td>
<td>run</td>
<td>作为无参数或返回值的动作运行</td>
<td></td>
</tr>
<tr>
<td>Supplier<t></t></td>
<td>无</td>
<td>T</td>
<td>get</td>
<td>提供一个T类型的值</td>
<td></td>
</tr>
<tr>
<td>Consumer<t></t></td>
<td>T</td>
<td>void</td>
<td>accept</td>
<td>处理一个T类型的值</td>
<td>andThen</td>
</tr>
<tr>
<td>BiConsumer<t,u></t,u></td>
<td>T,U</td>
<td>void</td>
<td>accept</td>
<td>处理T和U类型的值</td>
<td>andThen</td>
</tr>
<tr>
<td>Function<t,r></t,r></td>
<td>T</td>
<td>R</td>
<td>apply</td>
<td>有一个T类型参数的函数</td>
<td>compose,andThen,identity</td>
</tr>
<tr>
<td>BiFunction<t,u,r></t,u,r></td>
<td>T,U</td>
<td>R</td>
<td>apply</td>
<td>有T和U类型参数的函数</td>
<td>andThen</td>
</tr>
<tr>
<td>UnaryOperator<t></t></td>
<td>T</td>
<td>T</td>
<td>apply</td>
<td>类型T上的一元操作符</td>
<td>compose,andThen,identity</td>
</tr>
<tr>
<td>BinaryOperator<t></t></td>
<td>T,T</td>
<td>T</td>
<td>apply</td>
<td>类型T上的二元操作符</td>
<td>andThen,maxBy,minBy</td>
</tr>
<tr>
<td>Predicate<t></t></td>
<td>T</td>
<td>boolean</td>
<td>test</td>
<td>布尔值函数</td>
<td>and,or,negate,isEqual</td>
</tr>
<tr>
<td>BiPredicate<t,u></t,u></td>
<td>T,U</td>
<td>boolean</td>
<td>test</td>
<td>有两个参数的布尔值函数</td>
<td>and,or,negate</td>
</tr>
</tbody>
</table>
<h3 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h3><p><code>Predicate</code> 是一个布尔类型的函数，该函数只有一个参数，该接口包含了多种默认方法，用于处理复杂的逻辑动词。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Predicate&lt;String&gt; predicate = (s) -&gt; s.length() &gt; <span class="number">0</span>;</div><div class="line"></div><div class="line">predicate.test(<span class="string">"foo"</span>);              <span class="comment">// true</span></div><div class="line">predicate.negate().test(<span class="string">"foo"</span>);     <span class="comment">// false</span></div><div class="line"></div><div class="line">Predicate&lt;Boolean&gt; nonNull = Objects::nonNull;</div><div class="line">Predicate&lt;Boolean&gt; isNull = Objects::isNull;</div><div class="line"></div><div class="line">Predicate&lt;String&gt; isEmpty = String::isEmpty;</div><div class="line">Predicate&lt;String&gt; isNotEmpty = isEmpty.negate();</div></pre></td></tr></table></figure></p>
<h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><p><code>Function</code>接受一个参数并且返回一个结果，可以使用默认方法（compose，andThen）将多个函数链接起来。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Function&lt;String, Integer&gt; toInteger = Integer::valueOf;</div><div class="line">Function&lt;String, String&gt; backToString = toInteger.andThen(String::valueOf);</div><div class="line"></div><div class="line">backToString.apply(<span class="string">"123"</span>);     <span class="comment">// "123"</span></div></pre></td></tr></table></figure></p>
<h3 id="Supplier"><a href="#Supplier" class="headerlink" title="Supplier"></a>Supplier</h3><p><code>Supplier</code>返回一个给定类型的结果，与<code>Function</code>不同的是，<code>Supplier</code>不接受任何参数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Supplier&lt;Person&gt; personSupplier = Person::<span class="keyword">new</span>;</div><div class="line">personSupplier.get();   <span class="comment">// new Person</span></div></pre></td></tr></table></figure></p>
<h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><p><code>Comsumer</code>代表了在一个输入参数上需要进行的操作.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Consumer&lt;Person&gt; greeter = (p) -&gt; System.out.println(<span class="string">"Hello, "</span> + p.firstName);</div><div class="line">greeter.accept(<span class="keyword">new</span> Person(<span class="string">"Luke"</span>, <span class="string">"Skywalker"</span>));</div></pre></td></tr></table></figure></p>
<h3 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h3><p><code>Comparator</code>在之前的 Java 版本就已经被熟知，Java 8 在这个接口中增加了多个默认方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Comparator&lt;Person&gt; comparator = (p1, p2) -&gt; p1.firstName.compareTo(p2.firstName);</div><div class="line"></div><div class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">"John"</span>, <span class="string">"Doe"</span>);</div><div class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">"Alice"</span>, <span class="string">"Wonderland"</span>);</div><div class="line"></div><div class="line">comparator.compare(p1, p2);             <span class="comment">// &gt; 0</span></div><div class="line">comparator.reversed().compare(p1, p2);  <span class="comment">// &lt; 0</span></div></pre></td></tr></table></figure></p>
<h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><p><code>Optional</code>并非是一个函数式接口，但却是一个精巧的工具接口，用来防止<code>NullPointerException</code>，这个概念对于下一部分显得很重要，所以我们在这快速浏览一下<code>Optional</code>是如何工作的。<br><code>Optional</code>是一个简单的值容器，这个值可以是 null，也可以是 non-null 的。考虑一个方法可能返回一个 non-null 值的结果，也有可能返回一个空值。在 Java 8中，为了不直接返回 null，你可以返回一个<code>Optional</code>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Optional&lt;String&gt; optional = Optional.of(<span class="string">"bam"</span>);</div><div class="line"></div><div class="line">optional.isPresent();           <span class="comment">// true</span></div><div class="line">optional.get();                 <span class="comment">// "bam"</span></div><div class="line">optional.orElse(<span class="string">"fallback"</span>);    <span class="comment">// "bam"</span></div><div class="line"></div><div class="line">optional.ifPresent((s) -&gt; System.out.println(s.charAt(<span class="number">0</span>)));     <span class="comment">// "b"</span></div></pre></td></tr></table></figure></p>
<h2 id="Streams"><a href="#Streams" class="headerlink" title="Streams"></a>Streams</h2><p><code>java.util.Stream</code>代表了可以在其上面执行一个或多个操作的元素序列。流操作是中间或者完结操作。完结操作会返回一个某种类型的值，而中间操作会返回流本身，因此你可以连续链接多个方法的调用。Stream 是在一个源的基础上创建出来的，例如<code>java.util.Collection</code>中的 lists 或 sets（不支持 maps）。流操作可以被顺序或者并行执行。<br>让我们先来了解下序列流是如何工作的，首先，我们通过字符串列表的形式创建一个示例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; stringCollection = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">stringCollection.add(<span class="string">"ddd2"</span>);</div><div class="line">stringCollection.add(<span class="string">"aaa2"</span>);</div><div class="line">stringCollection.add(<span class="string">"bbb1"</span>);</div><div class="line">stringCollection.add(<span class="string">"aaa1"</span>);</div><div class="line">stringCollection.add(<span class="string">"bbb3"</span>);</div><div class="line">stringCollection.add(<span class="string">"ccc"</span>);</div><div class="line">stringCollection.add(<span class="string">"bbb2"</span>);</div><div class="line">stringCollection.add(<span class="string">"ddd1"</span>);</div></pre></td></tr></table></figure></p>
<p>Java 8 中的集合已被拓展，因此你可以直接调用<code>Collection.stream()·</code>或<code>Collection.parallelStream()</code>来创建流。接下来的部分将会解释最常用的流操作。</p>
<h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><p>Filter 接受一个 predicate 类型的接口来过滤流中的元素。该操作是一个中间操作，因此它允许我们在返回结果的时候再调用其他流操作（forEach）。ForEach 接受一个 Consumer 类型的接口变量，用来执行对多虑的流中的每一个元素的操作。ForEach是一个完结操作，并且不返回流，因此我们不能再调用其他的流操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">stringCollection</div><div class="line">    .stream()</div><div class="line">    .filter((s) -&gt; s.startsWith(<span class="string">"a"</span>))</div><div class="line">    .forEach(System.out::println);</div><div class="line"></div><div class="line"><span class="comment">// "aaa2", "aaa1"</span></div></pre></td></tr></table></figure></p>
<h3 id="Sorted"><a href="#Sorted" class="headerlink" title="Sorted"></a>Sorted</h3><p>Sorted 是一个中间操作，其返回一个流排序后的视图，流中的元素默认按照自然顺序进行排序，除非你指定了一个<code>Comparator</code>接口来重定义排序规则。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">stringCollection</div><div class="line">    .stream()</div><div class="line">    .sorted()</div><div class="line">    .filter((s) -&gt; s.startsWith(<span class="string">"a"</span>))</div><div class="line">    .forEach(System.out::println);</div><div class="line"></div><div class="line"><span class="comment">// "aaa1", "aaa2"</span></div></pre></td></tr></table></figure></p>
<p>需要注意的是，<code>sorted</code>只是创建了流排序后的视图，并没有操作操作集合，集合中元素的顺序是没有改变的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">System.out.println(stringCollection);</div><div class="line"><span class="comment">// ddd2, aaa2, bbb1, aaa1, bbb3, ccc, bbb2, ddd1</span></div></pre></td></tr></table></figure></p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>中间操作<code>map</code>通过特定的接口将每个元素转换为另一个对象，下面的例子将每一个字符串转换为全为大写的字符串。当然，你可以使用<code>map</code>将每一个对象转换为其他类型。对于带泛型结果的流对象，具体的类型还要由传递给 map 的泛型方法来决定。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">stringCollection</div><div class="line">    .stream()</div><div class="line">    .map(String::toUpperCase)</div><div class="line">    .sorted((a, b) -&gt; b.compareTo(a))</div><div class="line">    .forEach(System.out::println);</div><div class="line"></div><div class="line"><span class="comment">// "DDD2", "DDD1", "CCC", "BBB3", "BBB2", "AAA2", "AAA1"</span></div></pre></td></tr></table></figure></p>
<h3 id="Match"><a href="#Match" class="headerlink" title="Match"></a>Match</h3><p>有多种匹配操作可以用来检查某一种规则是否与流对象相匹配。所有的匹配操作都是完结操作，并且返回一个 boolean 类型的结果。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">boolean</span> anyStartsWithA =</div><div class="line">    stringCollection</div><div class="line">        .stream()</div><div class="line">        .anyMatch((s) -&gt; s.startsWith(<span class="string">"a"</span>));</div><div class="line"></div><div class="line">System.out.println(anyStartsWithA);      <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">boolean</span> allStartsWithA =</div><div class="line">    stringCollection</div><div class="line">        .stream()</div><div class="line">        .allMatch((s) -&gt; s.startsWith(<span class="string">"a"</span>));</div><div class="line"></div><div class="line">System.out.println(allStartsWithA);      <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="keyword">boolean</span> noneStartsWithZ =</div><div class="line">    stringCollection</div><div class="line">        .stream()</div><div class="line">        .noneMatch((s) -&gt; s.startsWith(<span class="string">"z"</span>));</div><div class="line"></div><div class="line">System.out.println(noneStartsWithZ);      <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<h3 id="Count"><a href="#Count" class="headerlink" title="Count"></a>Count</h3><p>Count 是一个完结操作，它返回一个 long 类型数值，用来标识流对象中包含的元素数量。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">long</span> startsWithB =</div><div class="line">    stringCollection</div><div class="line">        .stream()</div><div class="line">        .filter((s) -&gt; s.startsWith(<span class="string">"b"</span>))</div><div class="line">        .count();</div><div class="line"></div><div class="line">System.out.println(startsWithB);    <span class="comment">// 3</span></div></pre></td></tr></table></figure></p>
<h3 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h3><p>这个完结操作通过给定的函数来对流元素进行削减操作，该缩减操作的结果保存在<code>Optional</code>变量中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Optional&lt;String&gt; reduced =</div><div class="line">    stringCollection</div><div class="line">        .stream()</div><div class="line">        .sorted()</div><div class="line">        .reduce((s1, s2) -&gt; s1 + <span class="string">"#"</span> + s2);</div><div class="line"></div><div class="line">reduced.ifPresent(System.out::println);</div><div class="line"><span class="comment">// "aaa1#aaa2#bbb1#bbb2#bbb3#ccc#ddd1#ddd2"</span></div></pre></td></tr></table></figure></p>
<h2 id="Parallel-Streams"><a href="#Parallel-Streams" class="headerlink" title="Parallel Streams"></a>Parallel Streams</h2><p>正如上面提到的，stream 可以是顺序的也可以是并行的。顺序操作通过单线程执行，而并行操作通过多线程执行。<br>下面的例子说明了使用并行流提高运行效率是多么的容易。<br>首先我们创建一个包含不同元素的列表：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> max = <span class="number">1000000</span>;</div><div class="line">List&lt;String&gt; values = <span class="keyword">new</span> ArrayList&lt;&gt;(max);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; max; i++) &#123;</div><div class="line">    UUID uuid = UUID.randomUUID();</div><div class="line">    values.add(uuid.toString());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>现在我们测量一下对这个集合进行排序需要花的时间。</p>
<ul>
<li>Sequential Sort</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">long</span> t0 = System.nanoTime();</div><div class="line"></div><div class="line"><span class="keyword">long</span> count = values.stream().sorted().count();</div><div class="line">System.out.println(count);</div><div class="line"></div><div class="line"><span class="keyword">long</span> t1 = System.nanoTime();</div><div class="line"></div><div class="line"><span class="keyword">long</span> millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);</div><div class="line">System.out.println(String.format(<span class="string">"sequential sort took: %d ms"</span>, millis));</div><div class="line"></div><div class="line"><span class="comment">// sequential sort took: 899 ms</span></div></pre></td></tr></table></figure>
<ul>
<li>Parallel Sort</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">long</span> t0 = System.nanoTime();</div><div class="line"></div><div class="line"><span class="keyword">long</span> count = values.parallelStream().sorted().count();</div><div class="line">System.out.println(count);</div><div class="line"></div><div class="line"><span class="keyword">long</span> t1 = System.nanoTime();</div><div class="line"></div><div class="line"><span class="keyword">long</span> millis = TimeUnit.NANOSECONDS.toMillis(t1 - t0);</div><div class="line">System.out.println(String.format(<span class="string">"parallel sort took: %d ms"</span>, millis));</div><div class="line"></div><div class="line"><span class="comment">// parallel sort took: 472 ms</span></div></pre></td></tr></table></figure>
<p>两个代码片段几乎一样，但是使用并行操作来排序的效率提高了接近一半，而你需要做得就仅是将<code>stream</code>替换为<code>parallelStream</code></p>
<h2 id="Map-1"><a href="#Map-1" class="headerlink" title="Map"></a>Map</h2><p>正如前面提到的，map 是不支持流操作的。<code>Map</code>接口本身没有可用的<code>stream()</code>方法，但是你可以根据键-值对或项通过<code>map.keySet().stream</code>，<code>map.values().stream()</code>和<code>map.entrySet().stream()</code>来创建指定的流。<br>此外，map 支持多种新的、有用的方法来处理常规任务。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">    map.putIfAbsent(i, <span class="string">"val"</span> + i);</div><div class="line">&#125;</div><div class="line"></div><div class="line">map.forEach((id, val) -&gt; System.out.println(val));</div></pre></td></tr></table></figure></p>
<p>上面的代码是自解释的，<code>putIfAbsent</code>防止我们写入额外的空值检查，<code>forEach</code>接受一个 Consumer 为 map 中的每一个值进行操作。<br>下面的例子说明了如何利用函数来计算 map 上的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">map.computeIfPresent(<span class="number">3</span>, (num, val) -&gt; val + num);</div><div class="line">map.get(<span class="number">3</span>);             <span class="comment">// val33</span></div><div class="line"></div><div class="line">map.computeIfPresent(<span class="number">9</span>, (num, val) -&gt; <span class="keyword">null</span>);</div><div class="line">map.containsKey(<span class="number">9</span>);     <span class="comment">// false</span></div><div class="line"></div><div class="line">map.computeIfAbsent(<span class="number">23</span>, num -&gt; <span class="string">"val"</span> + num);</div><div class="line">map.containsKey(<span class="number">23</span>);    <span class="comment">// true</span></div><div class="line"></div><div class="line">map.computeIfAbsent(<span class="number">3</span>, num -&gt; <span class="string">"bam"</span>);</div><div class="line">map.get(<span class="number">3</span>);             <span class="comment">// val33</span></div></pre></td></tr></table></figure></p>
<p>接下来，我们学习如何删除给定键的条目，只有当前键值映射到给定值时，才能删除指定条目<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">map.remove(<span class="number">3</span>, <span class="string">"val3"</span>);</div><div class="line">map.get(<span class="number">3</span>);             <span class="comment">// val33</span></div><div class="line"></div><div class="line">map.remove(<span class="number">3</span>, <span class="string">"val33"</span>);</div><div class="line">map.get(<span class="number">3</span>);             <span class="comment">// null</span></div></pre></td></tr></table></figure></p>
<p>另一个有用的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">map.getOrDefault(<span class="number">42</span>, <span class="string">"not found"</span>);  <span class="comment">// not found</span></div></pre></td></tr></table></figure></p>
<p>合并一个 map 的条目是很简单的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">map.merge(<span class="number">9</span>, <span class="string">"val9"</span>, (value, newValue) -&gt; value.concat(newValue));</div><div class="line">map.get(<span class="number">9</span>);             <span class="comment">// val9</span></div><div class="line"></div><div class="line">map.merge(<span class="number">9</span>, <span class="string">"concat"</span>, (value, newValue) -&gt; value.concat(newValue));</div><div class="line">map.get(<span class="number">9</span>);             <span class="comment">// val9concat</span></div></pre></td></tr></table></figure></p>
<p>如果不存在该键值的条目，合并或者将键/值放入 map 中，或者调用合并函数来更改现有值。</p>
<h2 id="日期API"><a href="#日期API" class="headerlink" title="日期API"></a>日期API</h2><p>Java 8 在<code>java.time</code>包下包含了全新的日期和时间 API，这个新的日期 API 与 <a href="http://www.joda.org/joda-time/" target="_blank" rel="external">Joda-Time 库</a>相似，但不完全一样。下面的例子涵盖了大部分新的 API。</p>
<h3 id="Clock"><a href="#Clock" class="headerlink" title="Clock"></a>Clock</h3><p>Clock 提供了对当前日期和时间的访问，Clocks 知道当前时区，可以使用它替代<code>System.currentTimeMillis()</code>来获取当前的毫秒时间。时间线上的某一时刻也由类<code>Instant</code>表示，Instants 可以用来创建遗留的<code>java.util.Date</code>对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Clock clock = Clock.systemDefaultZone();</div><div class="line"><span class="keyword">long</span> millis = clock.millis();</div><div class="line"></div><div class="line">Instant instant = clock.instant();</div><div class="line">Date legacyDate = Date.from(instant);   <span class="comment">// legacy java.util.Date</span></div></pre></td></tr></table></figure></p>
<h3 id="Timezones"><a href="#Timezones" class="headerlink" title="Timezones"></a>Timezones</h3><p>Timezone 由一个<code>ZoneId</code>来表示，他们可以通过静态工厂方法获得。时区定义了某一时刻和当地日期、时间之间转换的偏移量。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">System.out.println(ZoneId.getAvailableZoneIds());</div><div class="line"><span class="comment">// prints all available timezone ids</span></div><div class="line"></div><div class="line">ZoneId zone1 = ZoneId.of(<span class="string">"Europe/Berlin"</span>);</div><div class="line">ZoneId zone2 = ZoneId.of(<span class="string">"Brazil/East"</span>);</div><div class="line">System.out.println(zone1.getRules());</div><div class="line">System.out.println(zone2.getRules());</div><div class="line"></div><div class="line"><span class="comment">// ZoneRules[currentStandardOffset=+01:00]</span></div><div class="line"><span class="comment">// ZoneRules[currentStandardOffset=-03:00]</span></div></pre></td></tr></table></figure></p>
<h3 id="LocalTime"><a href="#LocalTime" class="headerlink" title="LocalTime"></a>LocalTime</h3><p>LocalTime 表示了一个没有指定时区的时间，例如 10 p.m 或者 17：30：15。下面的例子为上面定义的时区创建了两个本地时间，然后我们比较两个时间，并计算它们之间的小时和分钟之间的不同。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">LocalTime now1 = LocalTime.now(zone1);</div><div class="line">LocalTime now2 = LocalTime.now(zone2);</div><div class="line"></div><div class="line">System.out.println(now1.isBefore(now2));  <span class="comment">// false</span></div><div class="line"></div><div class="line"><span class="keyword">long</span> hoursBetween = ChronoUnit.HOURS.between(now1, now2);</div><div class="line"><span class="keyword">long</span> minutesBetween = ChronoUnit.MINUTES.between(now1, now2);</div><div class="line"></div><div class="line">System.out.println(hoursBetween);       <span class="comment">// -3</span></div><div class="line">System.out.println(minutesBetween);     <span class="comment">// -239</span></div></pre></td></tr></table></figure></p>
<p><code>LocalTime</code>带有多种工厂方法，以简化新实例的创建，包括对时间字符串进行解析操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">LocalTime late = LocalTime.of(<span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>);</div><div class="line">System.out.println(late);       <span class="comment">// 23:59:59</span></div><div class="line"></div><div class="line">DateTimeFormatter germanFormatter =</div><div class="line">    DateTimeFormatter</div><div class="line">        .ofLocalizedTime(FormatStyle.SHORT)</div><div class="line">        .withLocale(Locale.GERMAN);</div><div class="line"></div><div class="line">LocalTime leetTime = LocalTime.parse(<span class="string">"13:37"</span>, germanFormatter);</div><div class="line">System.out.println(leetTime);   <span class="comment">// 13:37</span></div></pre></td></tr></table></figure></p>
<h3 id="LocalDate"><a href="#LocalDate" class="headerlink" title="LocalDate"></a>LocalDate</h3><p>LocalDate 表示不同的日期，例如2014-03-11。它是不可变的，并且与<code>LocalTime</code>完全类似。下面的例子演示了如何通过加减日、月、年来计算新日期。需要注意的是，每一个操作都会返回一个新实例。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">LocalDate today = LocalDate.now();</div><div class="line">LocalDate tomorrow = today.plus(<span class="number">1</span>, ChronoUnit.DAYS);</div><div class="line">LocalDate yesterday = tomorrow.minusDays(<span class="number">2</span>);</div><div class="line"></div><div class="line">LocalDate independenceDay = LocalDate.of(<span class="number">2014</span>, Month.JULY, <span class="number">4</span>);</div><div class="line">DayOfWeek dayOfWeek = independenceDay.getDayOfWeek();</div><div class="line">System.out.println(dayOfWeek);    <span class="comment">// FRIDAY</span></div></pre></td></tr></table></figure></p>
<p>从字符串中解析 LocalDate 就跟解析 LocalTime 一样简单：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">DateTimeFormatter germanFormatter =</div><div class="line">    DateTimeFormatter</div><div class="line">        .ofLocalizedDate(FormatStyle.MEDIUM)</div><div class="line">        .withLocale(Locale.GERMAN);</div><div class="line"></div><div class="line">LocalDate xmas = LocalDate.parse(<span class="string">"24.12.2014"</span>, germanFormatter);</div><div class="line">System.out.println(xmas);   <span class="comment">// 2014-12-24</span></div></pre></td></tr></table></figure></p>
<h3 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a>LocalDateTime</h3><p>LocalDateTIme 表示的是日期-时间。它将日期和时间组合成一个实例。<code>LocalDateTime</code>是不可变的，与 <code>LocalTime</code>和<code>LocalDate</code>工作原理类似。我们可以利用方法去获取日期时间中的某些字段值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">LocalDateTime sylvester = LocalDateTime.of(<span class="number">2014</span>, Month.DECEMBER, <span class="number">31</span>, <span class="number">23</span>, <span class="number">59</span>, <span class="number">59</span>);</div><div class="line"></div><div class="line">DayOfWeek dayOfWeek = sylvester.getDayOfWeek();</div><div class="line">System.out.println(dayOfWeek);      <span class="comment">// WEDNESDAY</span></div><div class="line"></div><div class="line">Month month = sylvester.getMonth();</div><div class="line">System.out.println(month);          <span class="comment">// DECEMBER</span></div><div class="line"></div><div class="line"><span class="keyword">long</span> minuteOfDay = sylvester.getLong(ChronoField.MINUTE_OF_DAY);</div><div class="line">System.out.println(minuteOfDay);    <span class="comment">// 1439</span></div></pre></td></tr></table></figure></p>
<p>通过一个时区的附件信息可以转换为一个实例，这个实例很容易转为<code>java.util.Date</code>类型。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Instant instant = sylvester</div><div class="line">        .atZone(ZoneId.systemDefault())</div><div class="line">        .toInstant();</div><div class="line"></div><div class="line">Date legacyDate = Date.from(instant);</div><div class="line">System.out.println(legacyDate);     <span class="comment">// Wed Dec 31 23:59:59 CET 2014</span></div></pre></td></tr></table></figure></p>
<p>日期-时间的格式化类似于 Date 或 Time。我们可以使用自定义模式来取代预定义的格式进行格式化。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">DateTimeFormatter formatter =</div><div class="line">    DateTimeFormatter</div><div class="line">        .ofPattern(<span class="string">"MMM dd, yyyy - HH:mm"</span>);</div><div class="line"></div><div class="line">LocalDateTime parsed = LocalDateTime.parse(<span class="string">"Nov 03, 2014 - 07:13"</span>, formatter);</div><div class="line">String string = formatter.format(parsed);</div><div class="line">System.out.println(string);     <span class="comment">// Nov 03, 2014 - 07:13</span></div></pre></td></tr></table></figure></p>
<p>不像<code>java.text.NumberFormat</code>，<code>DateTimeFormatter</code>是不可变的并且是线程安全的。<br>了解更多有关日期格式化的信息可以参考<a href="https://docs.oracle.com/javase/8/docs/api/java/time/format/DateTimeFormatter.html" target="_blank" rel="external">这里</a></p>
<h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>Java 8中的注解是可重复的，我们直接通过一个例子来了解它。<br>首先，我们定义了一个包装注解，它包括了一个实际注解的数组：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@interface</span> Hints &#123;</div><div class="line">    Hint[] value();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@Repeatable</span>(Hints.class)</div><div class="line"><span class="meta">@interface</span> Hint &#123;</div><div class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Java 8 允许我们通过使用<code>@Repeatable</code>对同一类型使用多个注解</p>
<ul>
<li><p>变体一：使用注解容器（老方法）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Hints</span>(&#123;<span class="meta">@Hint</span>(<span class="string">"hint1"</span>), <span class="meta">@Hint</span>(<span class="string">"hint2"</span>)&#125;)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>变体二：使用可重复注解（新方法）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Hint</span>(<span class="string">"hint1"</span>)</div><div class="line"><span class="meta">@Hint</span>(<span class="string">"hint2"</span>)</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>使用变体2，Java 编译器隐式地对<code>@Hint</code>进行设置，这对于通过反射来读取注解信息非常重要。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Hint hint = Person.class.getAnnotation(Hint.class);</div><div class="line">System.out.println(hint);                   <span class="comment">// null</span></div><div class="line"></div><div class="line">Hints hints1 = Person.class.getAnnotation(Hints.class);</div><div class="line">System.out.println(hints1.value().length);  <span class="comment">// 2</span></div><div class="line"></div><div class="line">Hint[] hints2 = Person.class.getAnnotationsByType(Hint.class);</div><div class="line">System.out.println(hints2.length);          <span class="comment">// 2</span></div></pre></td></tr></table></figure></p>
<p>尽管我们不会在<code>Person</code>类中声明<code>@Hints</code>注解，但是它仍然可以通过<code>getAnnotation(Hint.class)</code>来读取。然后，更便利的方法是<code>getAnnotationByType</code>，它可以直接访问<code>@Hint</code>注解。<br>此外，Java 8 中关于注解的使用，其还拓展了两个新的目标：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(&#123;ElementType.TYPE_PARAMETER, ElementType.TYPE_USE&#125;)</div><div class="line"><span class="meta">@interface</span> MyAnnotation &#123;&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文译自&lt;a href=&quot;https://github.com/winterbe/java8-tutorial&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Java8-tutorial&lt;/a&gt;，并对其中内容进行了一些修改和补充。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://zhaoxizhang.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>&#39;test&#39;</title>
    <link href="https://zhaoxizhang.github.io/2017/08/08/test/"/>
    <id>https://zhaoxizhang.github.io/2017/08/08/test/</id>
    <published>2017-08-08T12:14:39.000Z</published>
    <updated>2017-08-09T01:53:33.445Z</updated>
    
    <content type="html"><![CDATA[<p>test</p>
<a id="more"></a>
<h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;test&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
